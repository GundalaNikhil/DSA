---
problem_id: REC_RECURSIVE_PARSER_GENERATOR__4266
display_id: NTB-REC-4266
slug: recursive-parser-generator
title: "Recursive Parser Generator"
difficulty: Medium
difficulty_score: 50
topics:
  - Recursion
tags:
  - algorithms
  - backtracking
  - coding-interviews
  - data-structures
  - recursion
  - recursive-parser-generator
  - technical-interview-prep
premium: false
subscription_tier: basic
time_limit: 2000
memory_limit: 256
---

# Recursive Parser Generator

## Problem Statement

You are given a context-free grammar and an input string. The grammar uses nonterminals `1..N` and terminals `'a'..'z'`.

A recursive descent parser can only be generated if the grammar has no left recursion reachable from the start symbol `S`.

Your tasks:

1. Detect whether left recursion is reachable from `S`.
2. If no left recursion, determine whether the input string can be generated by the grammar.

## Input Format

- First line: integers `N`, `R`, and `S`
- Next `R` lines: a rule `A len sym1 sym2 ... symlen`
  - `A` is the head nonterminal
  - each `sym` is either a terminal (lowercase letter) or a nonterminal written as `#x`
- Last line: the input string

## Output Format

- If left recursion is reachable from `S`, print `LEFT_RECURSION`
- Otherwise print `YES` if the string can be generated, else `NO`

## Constraints

- `1 <= N <= 2000`
- `1 <= R <= 20000`
- Total symbols across all rules <= 200000
- Input string length <= 2000

## Clarifying Notes

- Direct and indirect left recursion are both considered.
- The parser uses recursive descent with memoization on `(nonterminal, position)`.

## Example Input

```
2 2 1
1 2 #1 a
2 1 b
ba
```

## Example Output

```
LEFT_RECURSION
```
