Reviewing Topic: AdvancedGraphs
============================================================
ID: AGR-001
Problem File: AGR-001-min-cut-small-graph.md
Editorial File: AGR-001-min-cut-small-graph.md
-------------------- PROBLEM DESCRIPTION --------------------
# AGR-001: Minimum Cut on Small Graph
-------------------- PROBLEM CONSTRAINTS --------------------
- `1 <= n <= 200` - `0 <= m <= 2000` - `0 <= w <= 10^9` - `0 <= u, v < n`
-------------------- EDITORIAL SUMMARY ----------------------
Given an undirected weighted graph, find the **Global Minimum Cut**. This is the minimum total weight of edges that, if removed, would disconnect the graph into two non-empty components.
-------------------- EDITORIAL CONSTRAINTS ------------------
-   **Disconnected Graph:** If the graph is initially disconnected, the min cut is 0. Stoer-Wagner handles this naturally (a phase will find a 0-weight cut). -   **Self-Loops:** Merging nodes creates self-loops. These must be ignored or removed. -   **Adjacency Matrix:** Since N <= 200, an adjacency...
============================================================

ID: AGR-002
Problem File: AGR-002-max-flow-vertex-capacity.md
Editorial File: AGR-002-max-flow-vertex-capacity.md
-------------------- PROBLEM DESCRIPTION --------------------
# AGR-002: Max Flow With Vertex Capacities
-------------------- PROBLEM CONSTRAINTS --------------------
- `2 <= n <= 2000` - `0 <= m <= 5000` - `0 <= c <= 10^9` - `cap[i] = -1` or `0 <= cap[i] <= 10^9` - `0 <= s, t < n`, `s != t`
-------------------- EDITORIAL SUMMARY ----------------------
Compute the maximum flow in a network where not only edges but also **vertices** have capacity limits. A vertex capacity limits the total flow passing *through* that vertex.
-------------------- EDITORIAL CONSTRAINTS ------------------
-   **Infinite Capacity:** Input uses `-1`. Treat this as `10^18` (safe large number). -   **Source/Sink:** The problem says `s` and `t` have unlimited capacity. So `s_in -> s_out` and `t_in -> t_out` should be Infinite. -   **Node Indexing:** Original `i` maps to `2*i` and `2*i+1`. Total nodes `2*N...
============================================================

ID: AGR-003
Problem File: AGR-003-k-shortest-loopless-paths.md
Editorial File: AGR-003-k-shortest-loopless-paths.md
-------------------- PROBLEM DESCRIPTION --------------------
# AGR-003: K Shortest Paths (Loopless)
-------------------- PROBLEM CONSTRAINTS --------------------
- `1 <= n <= 500` - `0 <= m <= 5000` - `1 <= k <= 50` - `0 <= w <= 10^9` - `0 <= s, t < n`
-------------------- EDITORIAL SUMMARY ----------------------
Find the `K` shortest **simple** paths (paths without repeated vertices) from a source `s` to a target `t`. Output their lengths in ascending order.
-------------------- EDITORIAL CONSTRAINTS ------------------
-   **Simple Paths:** Crucial. Standard Eppsteinâ€™s algorithm finds paths with loops. Yen's handles simple paths if we explicitly block Root Path nodes. -   **Output:** Only lengths. If fewer than K exist, output as many as found. -   **Constraints:** N=500, K=50. Yen's is `O(K * N * (M + N log N))`....
============================================================

ID: AGR-004
Problem File: AGR-004-apsp-with-negatives.md
Editorial File: AGR-004-apsp-with-negatives.md
-------------------- PROBLEM DESCRIPTION --------------------
# AGR-004: All-Pairs Shortest Path With Negative Edges
-------------------- PROBLEM CONSTRAINTS --------------------
- `1 <= n <= 2000` - `0 <= m <= 5000` - `-10^9 <= w <= 10^9` - The graph has no negative cycles
-------------------- EDITORIAL SUMMARY ----------------------
Compute the shortest path distance between **every pair of nodes** in a graph that may contain **negative edge weights** (but no negative cycles).
-------------------- EDITORIAL CONSTRAINTS ------------------
-   **INF:** Use a large number (e.g., `1e18`) for unreachable nodes. -   **Output:** Print "INF" string for infinity. -   **Constraints:** N=2000. Floyd-Warshall (O(N^3)) is too slow. Johnson's (O(NM log N)) is required.
============================================================

ID: AGR-005
Problem File: AGR-005-bridges-and-2ecc.md
Editorial File: AGR-005-bridges-and-2ecc.md
-------------------- PROBLEM DESCRIPTION --------------------
# AGR-005: Bridges and 2-Edge-Connected Components
-------------------- PROBLEM CONSTRAINTS --------------------
- `1 <= n <= 200000` - `0 <= m <= 200000` - `0 <= u, v < n`
-------------------- EDITORIAL SUMMARY ----------------------
Identify all **bridges** in a graph and partition the vertices into **2-Edge-Connected Components (2ECCs)**. A 2ECC is a subgraph where removing any single edge does not disconnect the subgraph.
-------------------- EDITORIAL CONSTRAINTS ------------------
-   **Parallel Edges:** The problem doesn't explicitly forbid them. If parallel edges exist between `u` and `v`, `(u, v)` is NOT a bridge (unless all but one are removed, but here we consider the static graph). Standard logic: pass edge index to DFS to distinguish parallel edges. -   **Output Order:...
============================================================

ID: AGR-006
Problem File: AGR-006-articulation-and-bcc.md
Editorial File: AGR-006-articulation-and-bcc.md
-------------------- PROBLEM DESCRIPTION --------------------
# AGR-006: Articulation Points and Biconnected Components
-------------------- PROBLEM CONSTRAINTS --------------------
- `1 <= n <= 200000` - `0 <= m <= 200000` - `0 <= u, v < n`
-------------------- EDITORIAL SUMMARY ----------------------
Find all **Articulation Points** (vertices whose removal increases the number of connected components) and **Biconnected Components (BCCs)** (maximal subgraphs such that any two vertices in the subgraph can be connected by at least two vertex-disjoint paths).
-------------------- EDITORIAL CONSTRAINTS ------------------
-   **BCC Format:** A BCC is a set of vertices. Since an edge belongs to exactly one BCC, but a vertex can belong to multiple, we extract BCCs as sets of edges and then collect unique vertices. -   **Output:** APs sorted. BCCs in any order. -   **Disconnected Graph:** Handle by running DFS on all un...
============================================================

ID: AGR-007
Problem File: AGR-007-eulerian-trail-directed.md
Editorial File: AGR-007-eulerian-trail-directed.md
-------------------- PROBLEM DESCRIPTION --------------------
# AGR-007: Eulerian Trail With Directed Edges
-------------------- PROBLEM CONSTRAINTS --------------------
- `1 <= n <= 100000` - `0 <= m <= 200000` - `0 <= u, v < n`
-------------------- EDITORIAL SUMMARY ----------------------
Find a path in a directed graph that visits every edge exactly once. If the path starts and ends at the same vertex, it's an **Eulerian Circuit**. If they are different, it's an **Eulerian Trail**.
-------------------- EDITORIAL CONSTRAINTS ------------------
-   **M=0:** A graph with no edges has an Eulerian trail of length 1 (just the node). Output `YES` and any node. -   **Output Format:** `YES` followed by the sequence of nodes. -   **Edge Removal:** Efficiently remove edges. `adj[u].pop()` is O(1). Using an index pointer `ptr[u]` is cleaner.
============================================================

ID: AGR-008
Problem File: AGR-008-scc-compression.md
Editorial File: AGR-008-scc-compression.md
-------------------- PROBLEM DESCRIPTION --------------------
# AGR-008: Strongly Connected Components Compression
-------------------- PROBLEM CONSTRAINTS --------------------
- `1 <= n <= 200000` - `0 <= m <= 200000` - `0 <= u, v < n`
-------------------- EDITORIAL SUMMARY ----------------------
Decompose a directed graph into its **Strongly Connected Components (SCCs)**. Then, contract each SCC into a single node to form a **Condensation Graph**, which is always a Directed Acyclic Graph (DAG).
-------------------- EDITORIAL CONSTRAINTS ------------------
-   **Component IDs:** Can be any range `0` to `k-1`. -   **Duplicate Edges:** The condensation graph should not have multi-edges. `A->B` should appear once even if there are 100 edges from nodes in A to nodes in B. -   **Self-Loops:** The condensation graph is a DAG, so no self-loops `A->A` (edges ...
============================================================

ID: AGR-009
Problem File: AGR-009-bipartite-matching-node-capacity.md
Editorial File: AGR-009-bipartite-matching-node-capacity.md
-------------------- PROBLEM DESCRIPTION --------------------
# AGR-009: Maximum Matching with Node Capacities
-------------------- PROBLEM CONSTRAINTS --------------------
- `1 <= nU + nV <= 100000` - `0 <= m <= 200000` - `0 <= capU[i], capV[j] <= 10^9` - `0 <= u < nU`, `0 <= v < nV`
-------------------- EDITORIAL SUMMARY ----------------------
Find the maximum number of edges we can select in a bipartite graph such that each node `u` in the left set is incident to at most `capU[u]` selected edges, and each node `v` in the right set is incident to at most `capV[v]` selected edges.
-------------------- EDITORIAL CONSTRAINTS ------------------
-   **Capacities:** Can be large (`10^9`), so use `long` (64-bit integer) for flow. -   **Node Indexing:** Input gives `u` (0 to nU-1) and `v` (0 to nV-1). In the flow graph, you can map them to `1..nU` and `nU+1..nU+nV`. -   **Multiple Edges:** If input contains duplicate `u-v` edges, they are effe...
============================================================

ID: AGR-010
Problem File: AGR-010-bipartite-min-cost-vertex-cover.md
Editorial File: AGR-010-bipartite-min-cost-vertex-cover.md
-------------------- PROBLEM DESCRIPTION --------------------
# AGR-010: Minimum Cost Vertex Cover in Bipartite Graph
-------------------- PROBLEM CONSTRAINTS --------------------
- `1 <= nU + nV <= 100000` - `0 <= m <= 200000` - `0 <= weight <= 10^9` - `0 <= u < nU`, `0 <= v < nV`
-------------------- EDITORIAL SUMMARY ----------------------
Given a bipartite graph where each node has a weight, find a subset of vertices with the minimum total weight such that every edge is incident to at least one vertex in the subset.
-------------------- EDITORIAL CONSTRAINTS ------------------
-   **Weights:** Can be 0. Can be large (`10^9`). Use `long`. -   **INF:** Use a value larger than sum of all weights (e.g., `1e18`). -   **Output:** Only the cost is required, not the vertices.
============================================================

ID: AGR-011
Problem File: AGR-011-dinic-with-scaling.md
Editorial File: AGR-011-dinic-with-scaling.md
-------------------- PROBLEM DESCRIPTION --------------------
# AGR-011: Dinic With Scaling
-------------------- PROBLEM CONSTRAINTS --------------------
- `2 <= n <= 5000` - `0 <= m <= 20000` - `0 <= c <= 10^9` - `0 <= s, t < n`, `s != t`
-------------------- EDITORIAL SUMMARY ----------------------
Compute the maximum flow in a directed graph using **Dinic's Algorithm with Capacity Scaling**. This optimization helps when edge capacities are very large.
-------------------- EDITORIAL CONSTRAINTS ------------------
-   **Large Capacities:** Up to `10^9`. Scaling is effective here. -   **Flow:** Use `long` (64-bit). -   **Complexity:** Scaling adds a `log(MaxCap)` factor but reduces the dependence on E in practice for some cases, or ensures polynomial time `O(E^2 log C)` independent of flow value.
============================================================

ID: AGR-012
Problem File: AGR-012-mincost-flow-demands.md
Editorial File: AGR-012-mincost-flow-demands.md
-------------------- PROBLEM DESCRIPTION --------------------
# AGR-012: Minimum-Cost Flow With Demands
-------------------- PROBLEM CONSTRAINTS --------------------
- `1 <= n <= 500` - `0 <= m <= 2000` - `-10^9 <= b[i] <= 10^9` - `0 <= low <= high <= 10^9` - `-10^6 <= cost <= 10^6`
-------------------- EDITORIAL SUMMARY ----------------------
Find a flow in a network that satisfies node supply/demand constraints and edge lower/upper bound capacity constraints, while minimizing the total cost.
-------------------- EDITORIAL CONSTRAINTS ------------------
-   **Infeasible:** If `sum(positive b) != sum(negative b)` (after adjustments), or if max flow < required supply. -   **Negative Costs:** Allowed. Potentials handle this (unless negative cycle exists, but "circulation" usually implies finding optimal flow in DAG-like structure or saturating negativ...
============================================================

ID: AGR-013
Problem File: AGR-013-k-edge-disjoint-paths.md
Editorial File: AGR-013-k-edge-disjoint-paths.md
-------------------- PROBLEM DESCRIPTION --------------------
# AGR-013: K-Edge-Disjoint Paths
-------------------- PROBLEM CONSTRAINTS --------------------
- `1 <= n <= 100000` - `0 <= m <= 200000` - `1 <= k <= 10000` - `0 <= s, t < n`, `s != t`
-------------------- EDITORIAL SUMMARY ----------------------
Determine if there are at least `k` paths from a source `s` to a sink `t` such that no two paths share an edge.
-------------------- EDITORIAL CONSTRAINTS ------------------
-   **Directed:** Edges are directed. `u->v` is distinct from `v->u`. -   **Optimization:** You can stop the max flow algorithm as soon as the flow reaches `k`. -   **Constraints:** `N=100,000`. Dinic is efficient on unit capacity networks (`O(min(V^{2/3}, E^{1/2}) * E)`).
============================================================

ID: AGR-014
Problem File: AGR-014-tree-diameter-after-removal.md
Editorial File: AGR-014-tree-diameter-after-removal.md
-------------------- PROBLEM DESCRIPTION --------------------
# AGR-014: Tree Diameter With Edge Removal
-------------------- PROBLEM CONSTRAINTS --------------------
- `2 <= n <= 200000` - `0 <= u, v < n`
-------------------- EDITORIAL SUMMARY ----------------------
For every edge in a tree, if we remove it, the tree splits into two components. Calculate the diameter of each component, take the maximum of these two, and find the maximum such value over all possible edge removals.
-------------------- EDITORIAL CONSTRAINTS ------------------
-   **N:** Up to 200,000. `O(N)` required. -   **Edges:** Unweighted (length 1). -   **Output:** Max of (diam(comp1), diam(comp2)) over all edges.
============================================================

ID: AGR-015
Problem File: AGR-015-directed-cycle-basis.md
Editorial File: AGR-015-directed-cycle-basis.md
-------------------- PROBLEM DESCRIPTION --------------------
# AGR-015: Directed Cycle Basis
-------------------- PROBLEM CONSTRAINTS --------------------
- `1 <= n <= 500` - `0 <= m <= 2000` - `0 <= u, v < n`
-------------------- EDITORIAL SUMMARY ----------------------
Find a **Cycle Basis** of a directed graph consisting of `m - n + c` simple directed cycles, where `m` is edges, `n` is vertices, and `c` is connected components (in the underlying undirected sense).
-------------------- EDITORIAL CONSTRAINTS ------------------
-   **Basis Size:** Strictly `m - n + c`. If the graph doesn't support this many directed cycles, the problem constraints/type usually ensure it (e.g., strongly connected components or specific structure). -   **Output Format:** First line `b` (number of cycles). Then each cycle. -   **Cycle Format:...
============================================================

ID: AGR-016
Problem File: AGR-016-offline-lca-with-mods.md
Editorial File: AGR-016-offline-lca-with-mods.md
-------------------- PROBLEM DESCRIPTION --------------------
# AGR-016: Offline Lowest Common Ancestor with Modifications
-------------------- PROBLEM CONSTRAINTS --------------------
- `1 <= n <= 200000` - `1 <= q <= 200000` - `0 <= u, v < n` - Operations are valid and keep the active edges acyclic
-------------------- EDITORIAL SUMMARY ----------------------
Given an initial tree, process `cut` (remove edge), `link` (add edge), and `query` (find LCA) operations. The active edges always form a forest.
-------------------- EDITORIAL CONSTRAINTS ------------------
-   **Base Tree:** We assume `link` restores initial edges. -   **Disconnected:** Output -1. -   **Offline:** We read all queries first.
============================================================

