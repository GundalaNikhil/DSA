<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SEG-001: Star Energy Scanner</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Exo+2&display=swap" rel="stylesheet">
    <style>
        :root { --bg: #050510; --star: #ffd700; --beam: #00d4ff; --panel: rgba(20,20,40,0.8); --text: #eee; --node: #2a2a4e; }
        * { box-sizing: border-box; }
        body { font-family: 'Exo 2', sans-serif; background: var(--bg); color: var(--text); margin: 0; min-height: 100vh; display: flex; flex-direction: column; overflow-x: hidden; }
        header { background: rgba(0,0,0,0.5); padding: 1rem 2rem; display: flex; justify-content: space-between; align-items: center; border-bottom: 2px solid var(--beam); }
        h1 { margin: 0; font-family: 'Orbitron', sans-serif; color: var(--beam); text-shadow: 0 0 10px var(--beam); }
        main { flex: 1; display: flex; flex-direction: column; align-items: center; padding: 20px; gap: 20px; }
        .instructions { background: var(--panel); padding: 15px 30px; border-radius: 10px; text-align: center; border: 1px solid var(--beam); max-width: 700px; }
        .galaxy-view { width: 100%; max-width: 800px; padding: 30px 10px; display: flex; justify-content: space-around; align-items: flex-end; height: 150px; border-bottom: 2px solid #333; position: relative; }
        .star-col { display: flex; flex-direction: column; align-items: center; gap: 5px; width: 60px; cursor: pointer; transition: transform 0.2s; position: relative; }
        .star-col:hover { transform: scale(1.1); }
        .star-orb { width: 30px; height: 30px; border-radius: 50%; background: var(--star); box-shadow: 0 0 20px var(--star); transition: all 0.5s; position: relative; z-index: 2; }
        .energy-bar { width: 10px; background: rgba(255, 215, 0, 0.3); border-radius: 5px; transition: height 0.5s; }
        .idx-label { font-family: 'Orbitron'; font-size: 0.8rem; color: #666; margin-top: 5px; }
        .tree-viz { width: 100%; max-width: 900px; height: 300px; background: rgba(0,0,0,0.3); border-radius: 10px; position: relative; overflow: hidden; margin-top: 20px; }
        .tree-node { position: absolute; width: 40px; height: 40px; background: var(--node); border: 2px solid #444; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 0.7rem; font-family: 'Orbitron'; color: #fff; transition: all 0.3s; z-index: 5; }
        .tree-node.active { background: var(--beam); border-color: #fff; box-shadow: 0 0 15px var(--beam); color: #000; transform: scale(1.2); }
        .tree-node.query-range { background: var(--star); color: #000; box-shadow: 0 0 15px var(--star); }
        .link { position: absolute; height: 2px; background: #333; transform-origin: 0 50%; z-index: 1; transition: all 0.3s; }
        .link.active { background: var(--beam); height: 3px; box-shadow: 0 0 5px var(--beam); }
        .controls { display: flex; gap: 15px; padding: 15px; background: var(--panel); border-radius: 10px; align-items: center; flex-wrap: wrap; justify-content: center; }
        .control-group { display: flex; gap: 5px; align-items: center; }
        .input-box { width: 50px; padding: 5px; background: #000; border: 1px solid var(--beam); color: var(--beam); text-align: center; font-family: 'Orbitron'; }
        .btn { background: var(--beam); color: #000; border: none; padding: 10px 20px; font-family: 'Orbitron'; cursor: pointer; border-radius: 5px; font-weight: bold; transition: all 0.2s; }
        .btn:hover { background: #fff; box-shadow: 0 0 15px var(--beam); }
        .btn.update { background: var(--star); }
        .scan-line { position: absolute; top: 0; bottom: 0; width: 2px; background: var(--beam); display: none; box-shadow: 0 0 10px var(--beam); pointer-events: none; }
        #status { height: 30px; color: var(--beam); font-family: 'Orbitron'; text-align: center; margin-top: 10px; }
    </style>
</head>
<body>
<header>
    <h1>SEG-001 STAR SYSTEM SCANNER</h1>
    <div>RANGE SUM QUERY</div>
</header>
<main>
    <div class="instructions">
        <b>MISSION:</b> Manage star energy levels. 
        <span style="color:var(--star)">UPDATE</span> star brightness individually. 
        <span style="color:var(--beam)">SCAN</span> sectors (Range Sum) to measure total energy.
        Observe the Segment Tree logic reacting!
    </div>
    
    <div class="galaxy-view" id="galaxy">
        <!-- Stars generated by JS -->
        <div class="scan-line" id="scanLine"></div>
    </div>
    
    <div class="controls">
        <div class="control-group">
            <span style="color:var(--star)">UPDATE STAR:</span>
            <input type="number" id="updIdx" class="input-box" placeholder="Idx" min="0" max="7">
            <input type="number" id="updVal" class="input-box" placeholder="Val" min="1" max="99">
            <button class="btn update" onclick="game.updateStar()">SET ENERGY</button>
        </div>
        <div style="width:2px;height:30px;background:#444;margin:0 10px"></div>
        <div class="control-group">
            <span style="color:var(--beam)">SCAN SECTOR:</span>
            <input type="number" id="qL" class="input-box" placeholder="L" min="0" max="7">
            <input type="number" id="qR" class="input-box" placeholder="R" min="0" max="7">
            <button class="btn" onclick="game.queryScan()">SCAN SUM</button>
        </div>
    </div>

    <div id="status">System Ready.</div>
    <div class="tree-viz" id="treeViz"></div>
</main>

<script>
class Game {
    constructor() {
        this.n = 8;
        this.arr = [10, 20, 15, 30, 25, 40, 10, 50];
        this.tree = new Array(4 * this.n).fill(0);
        this.nodes = {}; // map node index to element
        this.links = []; // store link info
        
        this.ui = {
            galaxy: document.getElementById('galaxy'),
            treeViz: document.getElementById('treeViz'),
            status: document.getElementById('status'),
            scanLine: document.getElementById('scanLine')
        };
        
        this.build(1, 0, this.n - 1);
        this.renderGalaxy();
        this.renderTreeStruct();
        this.updateTreeVis();
    }

    build(node, start, end) {
        if (start === end) {
            this.tree[node] = this.arr[start];
        } else {
            let mid = Math.floor((start + end) / 2);
            this.build(2 * node, start, mid);
            this.build(2 * node + 1, mid + 1, end);
            this.tree[node] = this.tree[2 * node] + this.tree[2 * node + 1];
        }
    }

    update(node, start, end, idx, val) {
        // Highlight current node
        this.highlightNode(node, 'active');
        
        if (start === end) {
            this.arr[idx] = val;
            this.tree[node] = val;
            // Visual update leaf
        } else {
            let mid = Math.floor((start + end) / 2);
            if (start <= idx && idx <= mid) {
                this.update(2 * node, start, mid, idx, val);
            } else {
                this.update(2 * node + 1, mid + 1, end, idx, val);
            }
            this.tree[node] = this.tree[2 * node] + this.tree[2 * node + 1];
        }
    }

    query(node, start, end, l, r) {
        this.highlightNode(node, 'active');
        
        if (r < start || end < l) return 0;
        
        if (l <= start && end <= r) {
            this.highlightNode(node, 'query-range');
            return this.tree[node];
        }
        
        let mid = Math.floor((start + end) / 2);
        let p1 = this.query(2 * node, start, mid, l, r);
        let p2 = this.query(2 * node + 1, mid + 1, end, l, r);
        return p1 + p2;
    }

    // --- Interaction ---

    updateStar() {
        let idx = parseInt(document.getElementById('updIdx').value);
        let val = parseInt(document.getElementById('updVal').value);
        
        if (isNaN(idx) || idx < 0 || idx >= this.n) return this.setStatus('Invalid Index!', 'red');
        if (isNaN(val)) return this.setStatus('Invalid Value!', 'red');

        this.clearHighlights();
        this.setStatus(`Updating Star ${idx} energy to ${val}...`);
        
        // Animate call
        this.update(1, 0, this.n - 1, idx, val);
        
        setTimeout(() => {
            this.renderGalaxy();
            this.updateTreeVis();
            this.setStatus(`Update Complete. New Galaxy Energy: ${this.tree[1]}`);
        }, 500);
    }

    queryScan() {
        let l = parseInt(document.getElementById('qL').value);
        let r = parseInt(document.getElementById('qR').value);
        
        if (isNaN(l) || isNaN(r) || l > r || l < 0 || r >= this.n) return this.setStatus('Invalid Range!', 'red');

        this.clearHighlights();
        this.setStatus(`Scanning Sector [${l}, ${r}]...`);
        
        // Visual Scan Line
        let starEls = document.querySelectorAll('.star-col');
        let leftPos = starEls[l].offsetLeft;
        let rightPos = starEls[r].offsetLeft + starEls[r].offsetWidth;
        this.ui.scanLine.style.left = leftPos + 'px';
        this.ui.scanLine.style.width = (rightPos - leftPos) + 'px';
        this.ui.scanLine.style.display = 'block';
        this.ui.scanLine.style.background = 'rgba(0, 212, 255, 0.2)';
        
        // Compute
        let sum = this.query(1, 0, this.n - 1, l, r);
        
        setTimeout(() => {
            this.setStatus(`Sector Energy Sum: ${sum}`);
            this.ui.scanLine.style.display = 'none';
        }, 800);
    }

    // --- Visuals ---

    renderGalaxy() {
        // Keep scan line
        let scan = this.ui.scanLine;
        this.ui.galaxy.innerHTML = '';
        this.ui.galaxy.appendChild(scan);

        this.arr.forEach((val, i) => {
            let col = document.createElement('div');
            col.className = 'star-col';
            col.onclick = () => {
                document.getElementById('updIdx').value = i;
                document.getElementById('updVal').focus();
            };

            let bar = document.createElement('div');
            bar.className = 'energy-bar';
            bar.style.height = (val * 1.5) + 'px';

            let orb = document.createElement('div');
            orb.className = 'star-orb';
            // Brightness based on val
            let brightness = 0.5 + (val / 100);
            orb.style.filter = `brightness(${brightness})`;
            orb.style.boxShadow = `0 0 ${val/2}px var(--star)`;

            let label = document.createElement('div');
            label.className = 'idx-label';
            label.innerText = i;

            col.appendChild(orb);
            col.appendChild(bar);
            col.appendChild(label);
            this.ui.galaxy.appendChild(col);
        });
    }

    renderTreeStruct() {
        // Simple BFS layout
        this.ui.treeViz.innerHTML = '';
        let levels = 4;
        let width = this.ui.treeViz.offsetWidth;
        let height = this.ui.treeViz.offsetHeight;
        
        // Store positions
        this.nodePos = {};
        
        let queue = [{node: 1, x: width/2, y: 40, level: 0, gap: width/2}];
        this.nodes[1] = null; // visual element holder

        // Precompute positions logic is tricky for varying depth, 
        // strictly binary heap logic for n=8 is perfect tree depth 3 (0-3)
        // nodes 1..15
        
        const drawNode = (n, x, y, level) => {
            let el = document.createElement('div');
            el.className = 'tree-node';
            el.style.left = (x - 20) + 'px';
            el.style.top = (y - 20) + 'px';
            el.id = 'node-' + n;
            this.ui.treeViz.appendChild(el);
            
            // Draw link to parent
            if (n > 1) {
                let p = Math.floor(n/2);
                let pPos = this.nodePos[p];
                if (pPos) {
                    let link = document.createElement('div');
                    link.className = 'link';
                    // math for line
                    let dx = x - pPos.x;
                    let dy = y - pPos.y;
                    let length = Math.sqrt(dx*dx + dy*dy);
                    let angle = Math.atan2(dy, dx) * 180 / Math.PI;
                    
                    link.style.width = length + 'px';
                    link.style.left = pPos.x + 'px';
                    link.style.top = pPos.y + 'px';
                    link.style.transform = `rotate(${angle}deg)`;
                    link.id = 'link-' + n;
                    this.ui.treeViz.prepend(link); // behind nodes
                }
            }
            
            this.nodePos[n] = {x, y};
            this.nodes[n] = el;
            
            if (level < 3) {
                 // Left
                 drawNode(2*n, x - width/(Math.pow(2, level+2)), y + 70, level+1);
                 // Right
                 drawNode(2*n+1, x + width/(Math.pow(2, level+2)), y + 70, level+1);
            }
        };

        drawNode(1, width/2, 40, 0);
    }

    updateTreeVis() {
        for (let i = 1; i < 16; i++) { // n=8 -> tree size 15 for full binary
            if (this.nodes[i]) {
                let val = this.tree[i];
                if (val !== undefined) this.nodes[i].innerText = val;
            }
        }
    }

    highlightNode(n, type) {
        if (this.nodes[n]) {
            setTimeout(() => {
                this.nodes[n].classList.add(type);
                if (document.getElementById('link-'+n)) document.getElementById('link-'+n).classList.add('active');
            }, 0);
        }
    }

    clearHighlights() {
        document.querySelectorAll('.tree-node').forEach(el => el.classList.remove('active', 'query-range'));
        document.querySelectorAll('.link').forEach(el => el.classList.remove('active'));
    }

    setStatus(msg, color='var(--beam)') {
        this.ui.status.innerText = msg;
        this.ui.status.style.color = color;
    }
}

const game = new Game();
</script>
</body>
</html>
