<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GRB-003: Royal Pathfinder</title>
    <link href="https://fonts.googleapis.com/css2?family=MedievalSharp&family=Share+Tech+Mono&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg: #1a0f00;
            --stone: #2c2417;
            --gold: #ffd700;
            --royal-blue: #002366;
            --chest: #8b4513;
            --road: #808080;
            --path-glow: rgba(255, 215, 0, 0.6);
            --text: #f0e68c;
        }

        body {
            font-family: 'Share Tech Mono', monospace;
            background: var(--bg);
            color: var(--text);
            margin: 0;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            user-select: none;
            background-image: 
                radial-gradient(circle at 10% 10%, rgba(139, 69, 19, 0.1) 0%, transparent 40%),
                radial-gradient(circle at 90% 90%, rgba(139, 69, 19, 0.1) 0%, transparent 40%);
        }

        header {
            background: var(--stone);
            padding: 1rem 2rem;
            display: flex; justify-content: space-between; align-items: center;
            border-bottom: 4px solid var(--gold);
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
        }

        h1 { 
            margin: 0; 
            font-family: 'MedievalSharp', cursive; 
            color: var(--gold); 
            font-size: 1.8rem;
            text-shadow: 2px 2px 4px #000;
        }

        main {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 2rem;
            gap: 20px;
        }

        .game-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            width: 100%;
            max-width: 900px;
        }

        .kingdom-container {
            position: relative;
            width: 650px;
            height: 450px;
            background: #2a3d2a; /* Mossy green ground */
            border-radius: 12px;
            border: 8px solid var(--stone);
            box-shadow: inset 0 0 50px rgba(0,0,0,0.5);
            overflow: hidden;
        }

        .castle-node {
            position: absolute;
            width: 60px;
            height: 60px;
            background: var(--stone);
            border: 3px solid #555;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 10;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            color: #fff;
            font-weight: bold;
        }

        .castle-node:hover { transform: scale(1.1) rotate(2deg); border-color: var(--gold); }
        .castle-node.source { border-color: var(--gold); box-shadow: 0 0 20px var(--gold); background: var(--royal-blue); }
        .castle-node.visited { background: #3d3d3d; border-color: var(--gold); }
        .castle-node.current { background: var(--gold); color: #000; box-shadow: 0 0 25px var(--gold); }

        .castle-node span { font-size: 0.7rem; color: var(--gold); margin-top: 2px; }

        .road-line {
            position: absolute;
            height: 6px;
            background: var(--road);
            transform-origin: left center;
            pointer-events: none;
            box-shadow: 0 0 5px rgba(0,0,0,0.3);
        }

        .road-line.path {
            background: var(--gold);
            height: 8px;
            box-shadow: 0 0 15px var(--gold);
        }

        .weight-badge {
            position: absolute;
            background: var(--chest);
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.8rem;
            border: 1px solid var(--gold);
            z-index: 11;
            transform: translate(-50%, -50%);
        }

        /* Drag and Drop Weight Chips */
        .chip-source {
            display: flex;
            gap: 15px;
            padding: 20px;
            background: var(--stone);
            border-radius: 12px;
            border: 2px dashed var(--gold);
            margin-top: 20px;
        }

        .weight-chip {
            width: 45px;
            height: 45px;
            background: radial-gradient(circle at 30% 30%, #ffd700, #b8860b);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #000;
            font-weight: bold;
            font-size: 1.2rem;
            cursor: grab;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.5);
            font-family: 'MedievalSharp', cursive;
        }

        .weight-chip:active { cursor: grabbing; transform: scale(1.1); }

        .stats-panel {
            display: flex;
            gap: 30px;
            padding: 15px 30px;
            background: var(--stone);
            border-radius: 12px;
            border: 1px solid var(--gold);
        }

        .stat-item {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .stat-label { color: #888; font-size: 0.7rem; font-family: 'MedievalSharp'; text-transform: uppercase; }
        .stat-value { font-size: 1.6rem; font-weight: bold; color: var(--gold); font-family: 'MedievalSharp'; }

        .btn {
            background: var(--royal-blue);
            color: var(--gold);
            border: 2px solid var(--gold);
            padding: 12px 30px;
            font-family: 'MedievalSharp', cursive;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s;
            border-radius: 5px;
            text-transform: uppercase;
        }

        .btn:hover { background: var(--gold); color: var(--royal-blue); box-shadow: 0 0 15px var(--gold); }
        .btn.secondary { background: var(--chest); border-color: #555; color: #ccc; }

        #status {
            min-height: 40px;
            font-weight: bold;
            font-size: 1.2rem;
            text-align: center;
            font-family: 'MedievalSharp';
            color: var(--gold);
            text-shadow: 1px 1px 2px #000;
        }

        .modal {
            position: fixed; inset: 0; background: rgba(0, 0, 0, 0.9);
            display: flex; align-items: center; justify-content: center;
            z-index: 100;
        }
        .modal.hidden { display: none; }
        
        .dialog {
            background: var(--stone); padding: 40px; border: 4px solid var(--gold);
            max-width: 550px; text-align: center; color: var(--text);
            border-radius: 15px;
        }
        .dialog h2 { color: var(--gold); font-family: 'MedievalSharp'; margin-top: 0; font-size: 2rem; }
    </style>
</head>
<body>

<header>
    <h1>üè∞ ROYAL PATHFINDER</h1>
    <div style="color: var(--gold); font-family: 'MedievalSharp'; font-size: 0.9rem;">GRB-003: DIJKSTRA'S ALGORITHM</div>
</header>

<main>
    <div class="game-area">
        <div style="color: #ccc; font-family: 'MedievalSharp';">Map the fastest messenger routes between royal castles!</div>

        <div class="kingdom-container" id="kingdomContainer">
            <!-- Road lines and castles will be generated here -->
        </div>

        <div style="color: var(--gold); font-family: 'MedievalSharp'; font-size: 0.9rem;">RESOURCES: DRAG WEIGHT TO SET ROAD COST</div>
        <div class="chip-source">
            <div class="weight-chip" draggable="true" data-weight="1">1</div>
            <div class="weight-chip" draggable="true" data-weight="2">2</div>
            <div class="weight-chip" draggable="true" data-weight="3">3</div>
            <div class="weight-chip" draggable="true" data-weight="5">5</div>
            <div class="weight-chip" draggable="true" data-weight="8">8</div>
            <div class="weight-chip" draggable="true" data-weight="10">10</div>
        </div>

        <div class="stats-panel">
            <div class="stat-item">
                <span class="stat-label">Castles</span>
                <span class="stat-value" id="castleCount">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Priority Queue</span>
                <span class="stat-value" id="pqSize">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Min Distance</span>
                <span class="stat-value" id="minDist">0</span>
            </div>
        </div>

        <div id="status"></div>

        <div style="display: flex; gap: 15px;">
            <button class="btn" onclick="game.step()">EXECUTE STEP</button>
            <button class="btn" onclick="game.autoRun()">GRAND TOUR</button>
            <button class="btn secondary" onclick="game.reset()">RESET BUDGET</button>
            <button class="btn secondary" onclick="game.newMap()">NEW KINGDOM</button>
        </div>
    </div>
</main>

<div id="modal" class="modal">
    <div class="dialog">
        <h2>üè∞ ROYAL PATHFINDER</h2>
        <div style="text-align:left; font-size:1rem; margin:1.5rem 0; line-height:1.6; color:#bbb; font-family: 'MedievalSharp';">
            <p><b style="color:var(--gold)">OBJECTIVE:</b> Find the shortest paths from the High Castle (0) using Dijkstra's Algorithm!</p>
            <p><b style="color:var(--gold)">MECHANICS:</b></p>
            <ul style="margin-left: 15px;">
                <li>Drag <b style="color:#fff">Gold Weights</b> onto <b style="color:#fff">Road Badges</b> to change road costs.</li>
                <li>Watch the <b style="color:var(--gold)">Priority Queue</b> select the closest unvisited castle.</li>
                <li>Dijkstra guarantees the shortest path in non-negative weighted graphs.</li>
            </ul>
            <p><b style="color:var(--gold)">PRO TIP:</b> Use low weights to force a path or high weights to bypass dangerous territories!</p>
        </div>
        <button class="btn" onclick="game.start()">ENTER KINGDOM</button>
    </div>
</div>

<script>
class MinHeap {
    constructor() { this.heap = []; }
    push(val) {
        this.heap.push(val);
        this.bubbleUp(this.heap.length - 1);
    }
    pop() {
        if (this.heap.length === 0) return null;
        const min = this.heap[0];
        const last = this.heap.pop();
        if (this.heap.length > 0) {
            this.heap[0] = last;
            this.bubbleDown(0);
        }
        return min;
    }
    bubbleUp(i) {
        while (i > 0) {
            let p = (i - 1) >> 1;
            if (this.heap[p][0] <= this.heap[i][0]) break;
            [this.heap[p], this.heap[i]] = [this.heap[i], this.heap[p]];
            i = p;
        }
    }
    bubbleDown(i) {
        while (true) {
            let l = 2 * i + 1, r = 2 * i + 2, min = i;
            if (l < this.heap.length && this.heap[l][0] < this.heap[min][0]) min = l;
            if (r < this.heap.length && this.heap[r][0] < this.heap[min][0]) min = r;
            if (min === i) break;
            [this.heap[min], this.heap[i]] = [this.heap[i], this.heap[min]];
            i = min;
        }
    }
    size() { return this.heap.length; }
}

class Game {
    constructor() {
        this.nodes = [];
        this.edges = []; // [u, v, w, id]
        this.adj = [];
        this.dist = [];
        this.visited = new Set();
        this.pq = new MinHeap();
        this.currentEdge = null;
        this.source = 0;
        this.autoInterval = null;
        
        this.ui = {
            container: document.getElementById('kingdomContainer'),
            pqSize: document.getElementById('pqSize'),
            castleCount: document.getElementById('castleCount'),
            minDist: document.getElementById('minDist'),
            status: document.getElementById('status'),
            modal: document.getElementById('modal')
        };

        this.setupDragEvents();
    }

    setupDragEvents() {
        document.querySelectorAll('.weight-chip').forEach(chip => {
            chip.addEventListener('dragstart', (e) => {
                e.dataTransfer.setData('text/plain', chip.dataset.weight);
            });
        });

        this.ui.container.addEventListener('dragover', (e) => e.preventDefault());
        this.ui.container.addEventListener('drop', (e) => {
            e.preventDefault();
            const badge = e.target.closest('.weight-badge');
            if (badge) {
                const weight = parseInt(e.dataTransfer.getData('text/plain'));
                const edgeId = parseInt(badge.dataset.id);
                this.updateEdgeWeight(edgeId, weight);
            }
        });
    }

    start() {
        this.ui.modal.classList.add('hidden');
        this.newMap();
    }

    newMap() {
        const n = Math.floor(Math.random() * 3) + 6;
        this.nodes = [];
        const positions = [];
        const centerX = 325, centerY = 225, radius = 160;
        for (let i = 0; i < n; i++) {
            const angle = (2 * Math.PI * i) / n - Math.PI / 2;
            this.nodes.push({
                x: centerX + radius * Math.cos(angle) + (Math.random() - 0.5) * 40,
                y: centerY + radius * Math.sin(angle) + (Math.random() - 0.5) * 40
            });
        }
        
        this.edges = [];
        this.adj = Array.from({length: n}, () => []);
        
        // Ensure connectivity
        for (let i = 1; i < n; i++) {
            const j = Math.floor(Math.random() * i);
            this.addEdge(i, j, Math.floor(Math.random() * 5) + 2);
        }
        
        // Add random spice
        const extra = Math.floor(Math.random() * 3) + 2;
        for (let k = 0; k < extra; k++) {
            const i = Math.floor(Math.random() * n), j = Math.floor(Math.random() * n);
            if (i !== j && !this.adj[i].some(e => e.to === j)) {
                this.addEdge(i, j, Math.floor(Math.random() * 5) + 3);
            }
        }
        
        this.reset();
    }

    addEdge(u, v, w) {
        const id = this.edges.length;
        this.edges.push({u, v, w, id});
        this.adj[u].push({to: v, w, id});
        this.adj[v].push({to: u, w, id});
    }

    updateEdgeWeight(id, w) {
        const edge = this.edges.find(e => e.id === id);
        if (edge) {
            edge.w = w;
            // Update adj
            this.adj[edge.u].find(n => n.id === id).w = w;
            this.adj[edge.v].find(n => n.id === id).w = w;
            this.reset();
        }
    }

    reset() {
        if (this.autoInterval) clearInterval(this.autoInterval);
        this.autoInterval = null;
        
        this.dist = new Array(this.nodes.length).fill(Infinity);
        this.dist[this.source] = 0;
        this.visited = new Set();
        this.pq = new MinHeap();
        this.pq.push([0, this.source]);
        this.currentId = null;
        
        this.ui.status.textContent = 'SET ROAD COSTS AND EXECUTE STEPS';
        this.render();
    }

    step() {
        if (this.pq.size() === 0) {
            this.ui.status.textContent = 'ALL CASTLES MAPPED BY ROYAL MESSENGERS!';
            return false;
        }

        const [d, u] = this.pq.pop();
        if (this.visited.has(u)) return this.step(); // Skip if already handled

        this.visited.add(u);
        this.currentId = u;
        this.ui.minDist.textContent = d === Infinity ? '‚àû' : d;

        for (const edge of this.adj[u]) {
            if (!this.visited.has(edge.to)) {
                if (this.dist[u] + edge.w < this.dist[edge.to]) {
                    this.dist[edge.to] = this.dist[u] + edge.w;
                    this.pq.push([this.dist[edge.to], edge.to]);
                }
            }
        }

        this.render();
        return this.pq.size() > 0;
    }

    autoRun() {
        if (this.autoInterval) return;
        this.autoInterval = setInterval(() => {
            if (!this.step()) {
                clearInterval(this.autoInterval);
                this.autoInterval = null;
            }
        }, 800);
    }

    render() {
        this.ui.container.innerHTML = '';
        
        // Render Edges
        this.edges.forEach(edge => {
            const u = this.nodes[edge.u], v = this.nodes[edge.v];
            const dx = v.x - u.x, dy = v.y - u.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            const angle = Math.atan2(dy, dx);
            
            const line = document.createElement('div');
            line.className = 'road-line';
            if (this.visited.has(edge.u) && this.visited.has(edge.v) && 
               (Math.abs(this.dist[edge.u] - this.dist[edge.v]) === edge.w)) {
                line.classList.add('path');
            }
            line.style.width = dist + 'px';
            line.style.left = u.x + 'px';
            line.style.top = u.y + 'px';
            line.style.transform = `rotate(${angle}rad)`;
            this.ui.container.appendChild(line);

            // Weight Badge (Drop Target)
            const badge = document.createElement('div');
            badge.className = 'weight-badge';
            badge.dataset.id = edge.id;
            badge.textContent = edge.w;
            badge.style.left = (u.x + v.x) / 2 + 'px';
            badge.style.top = (u.y + v.y) / 2 + 'px';
            this.ui.container.appendChild(badge);
        });

        // Render Nodes
        this.nodes.forEach((node, i) => {
            const el = document.createElement('div');
            el.className = 'castle-node';
            if (i === this.source) el.classList.add('source');
            if (this.visited.has(i)) el.classList.add('visited');
            if (this.currentId === i) el.classList.add('current');
            
            el.style.left = (node.x - 30) + 'px';
            el.style.top = (node.y - 30) + 'px';
            
            const name = document.createElement('div');
            name.textContent = i;
            el.appendChild(name);
            
            const dist = document.createElement('span');
            dist.textContent = this.dist[i] === Infinity ? '‚àû' : this.dist[i];
            el.appendChild(dist);
            
            this.ui.container.appendChild(el);
        });

        this.ui.castleCount.textContent = this.nodes.length;
        this.ui.pqSize.textContent = this.pq.size();
    }
}

const game = new Game();
</script>
</body>
</html>
