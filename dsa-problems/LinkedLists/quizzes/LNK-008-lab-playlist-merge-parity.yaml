problem_id: LNK_LAB_PLAYLIST_MERGE_PARITY_008
display_id: LNK-008
slug: lab-playlist-merge-parity
questions:
  - question: If L1 = [1, 2] and L2 = [3, 4], and we merge Evens followed by Odds, what is the result?
    difficulty: easy
    points: 10
    options:
      - 1, 2, 3, 4
      - 2, 4, 1, 3
      - 4, 2, 3, 1
      - 2, 1, 4, 3
    correct_answer: 1
    explanation: "Evens: 2 (from L1), 4 (from L2). Odds: 1 (from L1), 3 (from L2). Result: 2->4->1->3."
    type: single_choice
    id: prq_1
  - question: Why should we use 'dummy' heads for the even and odd sublists?
    difficulty: medium
    points: 15
    options:
      - To solve it in O(1) time
      - To avoid handling special cases for the first node
      - To sort the list
      - It saves memory
    correct_answer: 1
    explanation: Dummy nodes give us a stable reference to append to, even if the sublist starts empty.
    type: single_choice
    id: edq_1
  - question: What is a critical final step when merging sublists constructed from existing nodes?
    difficulty: easy
    points: 10
    options:
      - Reverse the lists
      - Set the last node's next pointer to null
      - Delete the original heads
      - Count the nodes
    correct_answer: 1
    explanation: If we don't null-terminate, the last node might still point to an old neighbor, creating a cycle.
    type: single_choice
    id: edq_2
  - question: Does this merge algorithm require allocating new Node objects?
    difficulty: easy
    points: 10
    options:
      - Yes, one for every element
      - No, only pointers are rearranged
      - Only for even numbers
      - Yes, to avoid destroying original lists
    correct_answer: 1
    explanation: We just rewire the 'next' pointers of existing nodes. O(1) space.
    type: single_choice
    id: edq_3
