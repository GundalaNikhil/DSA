<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GRD-010: Merge Queues</title>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka+One&family=Space+Mono&display=swap" rel="stylesheet">
    <style>
        :root { --bg: #1a1a2e; --queue: #9b59b6; --merged: #3498db; --cost: #e74c3c; --panel: #16213e; --text: #eee; }
        * { box-sizing: border-box; }
        body { font-family: 'Space Mono', monospace; background: var(--bg); color: var(--text); margin: 0; min-height: 100vh; display: flex; flex-direction: column; }
        header { background: var(--panel); padding: 1rem 2rem; display: flex; justify-content: space-between; align-items: center; border-bottom: 3px solid var(--queue); }
        h1 { margin: 0; font-family: 'Fredoka One', cursive; color: var(--queue); font-size: 1.6rem; }
        main { flex: 1; display: flex; flex-direction: column; align-items: center; padding: 1.5rem; gap: 15px; }
        .instructions { background: var(--panel); padding: 12px 25px; border-radius: 10px; text-align: center; max-width: 700px; border: 2px solid var(--queue); }
        .instructions b { color: var(--queue); }
        .queues-area { display: flex; flex-wrap: wrap; gap: 15px; padding: 20px; background: var(--panel); border-radius: 15px; justify-content: center; min-height: 100px; }
        .queue-block { padding: 15px 25px; background: rgba(155,89,182,0.3); border: 3px solid var(--queue); border-radius: 12px; cursor: pointer; transition: all 0.2s; font-size: 1.3rem; font-weight: bold; }
        .queue-block:hover { transform: scale(1.1); }
        .queue-block.selected { box-shadow: 0 0 20px var(--merged); border-color: var(--merged); }
        .merge-history { max-height: 150px; overflow-y: auto; padding: 15px; background: var(--panel); border-radius: 10px; width: 300px; }
        .merge-step { padding: 8px; margin-bottom: 5px; background: rgba(52,152,219,0.2); border-radius: 5px; font-size: 0.8rem; border-left: 3px solid var(--merged); }
        .side-panel { display: flex; gap: 20px; }
        .panel-box { background: var(--panel); border: 2px solid #333; padding: 15px; border-radius: 10px; min-width: 150px; }
        .stat-row { display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid #333; }
        .stat-label { color: #888; font-size: 0.75rem; }
        .stat-value { font-weight: bold; }
        .stat-value.cost { color: var(--cost); }
        .btn { background: var(--queue); color: #fff; border: none; padding: 12px 25px; font-family: 'Fredoka One'; cursor: pointer; border-radius: 8px; }
        .btn:hover { background: #8e44ad; }
        .btn.secondary { background: transparent; border: 2px solid #555; color: #888; }
        #status { font-size: 1rem; text-align: center; min-height: 30px; }
        .modal { position: fixed; inset: 0; background: rgba(0,0,0,0.95); display: flex; align-items: center; justify-content: center; z-index: 100; }
        .modal.hidden { display: none; }
        .dialog { background: var(--panel); padding: 30px; border: 3px solid var(--queue); max-width: 500px; text-align: center; border-radius: 15px; }
        .dialog h2 { color: var(--queue); font-family: 'Fredoka One'; }
    </style>
</head>
<body>
<header>
    <h1>ðŸ“š MERGE QUEUES</h1>
    <div style="color:#888">HUFFMAN-STYLE MERGING</div>
</header>
<main>
    <div class="instructions">
        <b>ðŸŽ¯ MERGE ALL QUEUES:</b> Select two queues to merge. 
        Cost = sum of their sizes. Minimize total merge cost!
    </div>
    <div class="queues-area" id="queuesArea"></div>
    <div style="display:flex; gap:20px;">
        <div class="merge-history">
            <div style="color:var(--merged); margin-bottom:10px; text-align:center;">MERGE HISTORY</div>
            <div id="history"></div>
        </div>
        <div class="side-panel">
            <div class="panel-box">
                <div class="stat-row"><span class="stat-label">Total Cost</span><span class="stat-value cost" id="totalCost">0</span></div>
                <div class="stat-row"><span class="stat-label">Optimal</span><span class="stat-value" id="optimal">?</span></div>
                <div class="stat-row"><span class="stat-label">Queues Left</span><span class="stat-value" id="queueCount">0</span></div>
            </div>
        </div>
    </div>
    <div id="status">Select two queues to merge!</div>
    <div style="display:flex; gap:15px;">
        <button class="btn" onclick="game.checkSolution()">CHECK</button>
        <button class="btn secondary" onclick="game.reset()">RESET</button>
        <button class="btn secondary" onclick="game.newGame()">NEW QUEUES</button>
    </div>
</main>
<div id="modal" class="modal">
    <div class="dialog">
        <h2>ðŸ“š MERGE QUEUES</h2>
        <div style="margin:20px 0; text-align:left; line-height:1.8;">
            <p><b style="color:var(--queue)">GOAL:</b> Merge all queues with minimum total cost!</p>
            <ul>
                <li>Select <b>two queues</b> to merge</li>
                <li>Merge cost = sum of both sizes</li>
                <li>Result is a new queue of combined size</li>
                <li>Continue until one queue remains!</li>
            </ul>
            <p style="color:#888">Greedy: Always merge the two smallest queues! (Huffman coding)</p>
        </div>
        <button class="btn" onclick="game.start()">START MERGING</button>
    </div>
</div>
<script>
class Game {
    constructor() {
        this.queues = []; this.selected = []; this.history = []; this.totalCost = 0;
        this.ui = { area: document.getElementById('queuesArea'), history: document.getElementById('history'), totalCost: document.getElementById('totalCost'), optimal: document.getElementById('optimal'), queueCount: document.getElementById('queueCount'), status: document.getElementById('status'), modal: document.getElementById('modal') };
    }
    start() { this.ui.modal.classList.add('hidden'); this.newGame(); }
    newGame() {
        const n = Math.floor(Math.random() * 3) + 4;
        this.initialQueues = Array.from({length: n}, () => Math.floor(Math.random() * 10) + 1);
        this.computeOptimal();
        this.reset();
    }
    computeOptimal() {
        // Min-heap simulation
        const heap = [...this.initialQueues].sort((a,b) => a - b);
        let cost = 0;
        while (heap.length > 1) {
            const a = heap.shift();
            const b = heap.shift();
            cost += a + b;
            heap.push(a + b);
            heap.sort((a,b) => a - b);
        }
        this.optimalCost = cost;
    }
    reset() { this.queues = [...this.initialQueues]; this.selected = []; this.history = []; this.totalCost = 0; this.ui.status.textContent = 'Select two queues to merge!'; this.ui.optimal.textContent = '?'; this.render(); }
    selectQueue(idx) {
        if (this.selected.includes(idx)) { this.selected = this.selected.filter(i => i !== idx); }
        else if (this.selected.length < 2) { this.selected.push(idx); }
        if (this.selected.length === 2) { this.merge(); }
        this.render();
    }
    merge() {
        const [i, j] = this.selected.sort((a,b) => b - a);
        const a = this.queues[i], b = this.queues[j];
        const cost = a + b;
        this.totalCost += cost;
        this.history.push(`${a} + ${b} = ${cost}`);
        this.queues.splice(i, 1);
        this.queues.splice(j, 1);
        this.queues.push(a + b);
        this.selected = [];
        this.ui.status.textContent = `Merged! Cost: ${cost}`;
        if (this.queues.length === 1) this.checkSolution();
    }
    checkSolution() {
        this.ui.optimal.textContent = this.optimalCost;
        if (this.totalCost === this.optimalCost) { this.ui.status.innerHTML = 'ðŸŽ‰ OPTIMAL! Minimum merge cost achieved!'; this.ui.status.style.color = '#2ecc71'; }
        else { this.ui.status.innerHTML = `Cost: ${this.totalCost} (Optimal: ${this.optimalCost})`; this.ui.status.style.color = '#ffd700'; }
    }
    render() {
        this.ui.area.innerHTML = '';
        this.queues.forEach((q, i) => {
            const el = document.createElement('div');
            el.className = 'queue-block';
            if (this.selected.includes(i)) el.classList.add('selected');
            el.textContent = q;
            el.onclick = () => this.selectQueue(i);
            this.ui.area.appendChild(el);
        });
        this.ui.history.innerHTML = '';
        this.history.forEach(h => {
            const step = document.createElement('div');
            step.className = 'merge-step';
            step.textContent = h;
            this.ui.history.appendChild(step);
        });
        this.ui.totalCost.textContent = this.totalCost;
        this.ui.queueCount.textContent = this.queues.length;
    }
}
const game = new Game();
</script>
</body>
</html>
