---
problem_id: DP_STRICT_JUMP_LIS__4257
display_id: DP-006
slug: strict-jump-lis-max-gap
title: "Strict Jump LIS With Max Gap - Quiz"
---

# Problem-Related Questions (PRQ)
# These test understanding of the problem statement, constraints, and requirements

problem_questions:
  - quiz_id: "PRQ-006-Q001"
    category: "problem"
    type: single_choice
    question: "What is the primary task in the Strict Jump LIS With Max Gap problem?"
    options:
      - option_id: "A"
        text: "Find the longest subsequence regardless of value constraints"
        correct: false
      - option_id: "B"
        text: "Find the longest increasing subsequence where consecutive elements differ by at most GAP"
        correct: true
      - option_id: "C"
        text: "Find the maximum gap between any two elements"
        correct: false
      - option_id: "D"
        text: "Sort the array with gap constraints"
        correct: false
    explanation: "This is LIS with an additional constraint: when extending the subsequence, the next element must be larger but not more than GAP units larger than the previous."
    difficulty: easy
    points: 10

  - quiz_id: "PRQ-006-Q002"
    category: "problem"
    type: single_choice
    question: "If the current LIS ends with value 10 and GAP=3, which values can extend it?"
    options:
      - option_id: "A"
        text: "Any value greater than 10"
        correct: false
      - option_id: "B"
        text: "Values in range (10, 13] only"
        correct: true
      - option_id: "C"
        text: "Values 11, 12, 13, 14, ..."
        correct: false
      - option_id: "D"
        text: "Only value 13"
        correct: false
    explanation: "With GAP=3, we can add elements in the range (10, 13], which includes 11, 12, and 13, but not 14 or higher (gap > 3) and not 10 or lower (not increasing)."
    difficulty: easy
    points: 10

  - quiz_id: "PRQ-006-Q003"
    category: "problem"
    type: single_choice
    question: "What happens if no valid subsequence of length > 1 can be formed due to gap constraints?"
    options:
      - option_id: "A"
        text: "Return 0"
        correct: false
      - option_id: "B"
        text: "Return 1 (single element subsequence)"
        correct: true
      - option_id: "C"
        text: "Return -1 to indicate impossibility"
        correct: false
      - option_id: "D"
        text: "Return the array length"
        correct: false
    explanation: "Every single element forms a valid increasing subsequence of length 1, so the minimum answer is always 1."
    difficulty: easy
    points: 10

  - quiz_id: "PRQ-006-Q004"
    category: "problem"
    type: multiple_choice
    question: "Which of the following are valid constraints for this problem? (Select all that apply)"
    options:
      - option_id: "A"
        text: "Subsequence must be strictly increasing"
        correct: true
      - option_id: "B"
        text: "Consecutive values in subsequence must differ by at most GAP"
        correct: true
      - option_id: "C"
        text: "Elements must maintain their relative order from the array"
        correct: true
      - option_id: "D"
        text: "All elements must be positive"
        correct: false
    explanation: "The subsequence must be strictly increasing with gap ≤ GAP between consecutive elements, maintaining array order. Elements can be negative."
    difficulty: medium
    points: 15

  - quiz_id: "PRQ-006-Q005"
    category: "problem"
    type: single_choice
    question: "Given array [1, 2, 5, 3, 4] with GAP=2, what is the longest valid subsequence?"
    options:
      - option_id: "A"
        text: "[1, 2, 3, 4] with length 4"
        correct: true
      - option_id: "B"
        text: "[1, 2, 5] with length 3"
        correct: false
      - option_id: "C"
        text: "[1, 3, 5] with length 3"
        correct: false
      - option_id: "D"
        text: "[2, 3, 4] with length 3"
        correct: false
    explanation: "The sequence [1, 2, 3, 4] is valid: 2-1=1≤2, 3-2=1≤2, 4-3=1≤2. The jump to 5 (5-2=3>2) violates the gap constraint."
    difficulty: medium
    points: 15

# Editorial/Algorithm Questions (EDQ)
# These test understanding of the solution approach, algorithms, and complexity analysis

editorial_questions:
  - quiz_id: "EDQ-006-Q001"
    category: "editorial"
    type: single_choice
    question: "What is the time complexity of the naive DP approach for this problem?"
    options:
      - option_id: "A"
        text: "O(N log N)"
        correct: false
      - option_id: "B"
        text: "O(N²)"
        correct: true
      - option_id: "C"
        text: "O(N * GAP)"
        correct: false
      - option_id: "D"
        text: "O(N)"
        correct: false
    explanation: "The naive DP checks each element against all previous elements to find valid extensions, resulting in O(N²) time complexity."
    difficulty: easy
    points: 10

  - quiz_id: "EDQ-006-Q002"
    category: "editorial"
    type: single_choice
    question: "Which data structure can optimize the solution to O(N log N)?"
    options:
      - option_id: "A"
        text: "Hash map"
        correct: false
      - option_id: "B"
        text: "Segment tree or Binary Indexed Tree (BIT)"
        correct: true
      - option_id: "C"
        text: "Stack"
        correct: false
      - option_id: "D"
        text: "Queue"
        correct: false
    explanation: "Segment tree or BIT can query the maximum LIS length in a value range [arr[i]-GAP, arr[i]-1] in O(log N), optimizing from O(N²) to O(N log N)."
    difficulty: medium
    points: 15

  - quiz_id: "EDQ-006-Q003"
    category: "editorial"
    type: single_choice
    question: "What is the key insight for optimizing this problem beyond O(N²)?"
    options:
      - option_id: "A"
        text: "Sort the array first"
        correct: false
      - option_id: "B"
        text: "Use range maximum query to find best previous LIS in valid value range"
        correct: true
      - option_id: "C"
        text: "Use binary search on the values"
        correct: false
      - option_id: "D"
        text: "Use greedy selection"
        correct: false
    explanation: "The optimization comes from realizing we need the maximum LIS length among all previous elements in the range [arr[i]-GAP, arr[i]-1], which is a range query problem."
    difficulty: hard
    points: 20

  - quiz_id: "EDQ-006-Q004"
    category: "editorial"
    type: scenario
    question: "You're analyzing stock prices where a valid trend can only have daily changes up to $GAP. Which algorithm applies?"
    options:
      - option_id: "A"
        text: "Standard longest increasing subsequence"
        correct: false
      - option_id: "B"
        text: "Strict jump LIS with max gap constraint"
        correct: true
      - option_id: "C"
        text: "Maximum subarray sum"
        correct: false
      - option_id: "D"
        text: "Sliding window maximum"
        correct: false
    explanation: "This models the strict jump LIS perfectly - finding the longest increasing price trend where consecutive prices don't jump by more than GAP."
    difficulty: easy
    points: 10

  - quiz_id: "EDQ-006-Q005"
    category: "editorial"
    type: scenario
    question: "Your O(N²) solution times out for N=100,000. What optimization should you implement?"
    options:
      - option_id: "A"
        text: "Use memoization"
        correct: false
      - option_id: "B"
        text: "Use segment tree/BIT for range maximum queries"
        correct: true
      - option_id: "C"
        text: "Use hash map for faster lookups"
        correct: false
      - option_id: "D"
        text: "Reduce space complexity"
        correct: false
    explanation: "O(N²) with N=100,000 means 10 billion operations. Using segment tree/BIT reduces complexity to O(N log N) ≈ 1.7 million operations, solving the timeout."
    difficulty: hard
    points: 20

  - quiz_id: "EDQ-006-Q006"
    category: "editorial"
    type: multiple_choice
    question: "Which of the following are common mistakes in this problem? (Select all that apply)"
    options:
      - option_id: "A"
        text: "Allowing gaps strictly greater than GAP instead of at most GAP"
        correct: true
      - option_id: "B"
        text: "Not handling the case where elements have the same value (non-strictly increasing)"
        correct: true
      - option_id: "C"
        text: "Using O(N²) approach without considering optimization for large N"
        correct: true
      - option_id: "D"
        text: "Using coordinate compression"
        correct: false
    explanation: "Common mistakes include wrong gap comparison (> vs ≤), allowing equal values, and not optimizing for large inputs. Coordinate compression is actually helpful, not a mistake."
    difficulty: hard
    points: 20

  - quiz_id: "EDQ-006-Q007"
    category: "editorial"
    type: single_choice
    question: "Why might coordinate compression be useful in the optimized solution?"
    options:
      - option_id: "A"
        text: "It reduces time complexity"
        correct: false
      - option_id: "B"
        text: "It reduces space complexity when values have large range but small count"
        correct: true
      - option_id: "C"
        text: "It's required for segment trees to work"
        correct: false
      - option_id: "D"
        text: "It makes the code simpler"
        correct: false
    explanation: "If values range from -10⁹ to 10⁹ but we only have N=10⁵ elements, coordinate compression maps them to [0, N), reducing segment tree size from ~2×10⁹ to ~2×10⁵."
    difficulty: medium
    points: 15
