---
problem_id: MTH_BERLEKAMP_MASSEY__5628
display_id: MTH-010
slug: berlekamp-massey
title: "Berlekamp-Massey Sequence Reconstruction"
difficulty: Hard
difficulty_score: 80
topics:
  - MathAdvanced
  - Berlekamp-Massey
tags:
  - math-advanced
  - berlekamp-massey
  - hard
premium: true
subscription_tier: basic
---

# MTH-010: Berlekamp-Massey Sequence Reconstruction

## üìã Problem Summary

Given the first `m` terms of a sequence, find the **shortest linear recurrence** that generates it. Then, use this recurrence to find the `n`-th term.
- Input: `S_0, S_1, dots, S_m-1`.
- Output: `S_n +/-odMOD`.

## üåç Real-World Scenario

**Scenario Title:** The Alien Signal Decoder

Astronomers receive a stream of numbers from a pulsar. The sequence looks random, but they suspect it's generated by a linear feedback shift register (LFSR) used by an alien civilization (or just a satellite).
- To predict the next signals or decode the transmission, they need to find the "rule" (recurrence relation) governing the sequence.
- If the sequence is `1, 1, 2, 3, 5, 8`, the rule is likely `S_n = S_n-1 + S_n-2`.
- Berlekamp-Massey is the algorithm that finds this rule using the minimum number of observed terms.

**Why This Problem Matters:**

- **Coding Theory:** Decoding BCH and Reed-Solomon codes.
- **Cryptography:** Breaking stream ciphers by finding the linear complexity of the keystream.
- **Compression:** Predicting future values in a time series.

![Real-World Application](../images/MTH-010/real-world-scenario.png)

## Detailed Explanation

### ASCII Diagram: Algorithm State

We maintain a current recurrence `C(x)` and a "correction" recurrence from a previous step.

```
Step i: Process S[i]
Compute discrepancy d = S[i] - sum(C[j] * S[i-j])

If d == 0:
    Continue (Current rule works)
Else:
    Adjust C(x) using previous best rule B(x)
    C_new(x) = C(x) - d/d_old * x^(i - fail_index) * B(x)
```

### ‚úÖ Input/Output Clarifications (Read This Before Coding)

- **Input:** Sequence `S` of length `m`. Target index `n`.
- **Output:** `S_n`.
- **Constraint:** `m <= 4000`. This allows `O(m^2)` for finding the recurrence.
- **Large N:** Once we have the recurrence of length `L`, we can compute `S_n` in `O(L^2 log n)` or `O(L log L log n)` using Kitamasa method or Matrix Exponentiation. Given `L ~= m/2 ~= 2000`, Matrix Exp (`L^3`) is too slow (`8 x 10^9`). We need **Kitamasa Method** (Polynomial Modulo).

### Core Concept: Kitamasa Method

Instead of full matrix exponentiation, we compute `x^n +/-odP(x)`, where `P(x)` is the characteristic polynomial of the recurrence.
If `x^n equiv sum_i=0^L-1 c_i x^i +/-odP(x)`, then `S_n = sum_i=0^L-1 c_i S_i`.
Polynomial multiplication takes `O(L log L)` or `O(L^2)`. With `L=2000`, `O(L^2)` is `4 x 10^6`, times `log n ~= 60`, total `2.4 x 10^8`. This fits in 2 seconds.

## Naive Approach

### Intuition

Guess patterns? Impossible for general case.

### Algorithm

None.

## Optimal Approach

### Key Insight

1. **Berlekamp-Massey:** Find recurrence `C` in `O(m^2)`.
2. **Linear Recurrence Solver:** Compute `S_n` using the recurrence. Since `L` can be up to 2000, use `O(L^2 log n)` polynomial modulo exponentiation.

### Algorithm

1. **Berlekamp-Massey:**
   - Init `C = [1]`, `B = [1]`.
   - Iterate `i` from 0 to `m-1`.
   - Calculate `delta = S[i] + sum(C[j] * S[i-j])`.
   - If `delta == 0`, continue.
   - Update `C` using `B`.
   - If `2L <= i`, update `B` to old `C`, update `L`.
2. **N-th Term:**
   - Characteristic Poly `P(x) = x^L - sum C_j x^L-j`.
   - Compute `R(x) = x^n +/-odP(x)` using binary exponentiation.
   - Result is `sum R_i S_i`.

### Time Complexity

- **O(m^2 + L^2 \log n)**.

### Space Complexity

- **O(m)**.

![Algorithm Visualization](../images/MTH-010/algorithm-visualization.png)
![Algorithm Steps](../images/MTH-010/algorithm-steps.png)

## Implementations

### Java


### Python


### C++


### JavaScript


## üß™ Test Case Walkthrough (Dry Run)

Input: `S = [1, 1, 2, 3, 5, 8]`.
1. `i=0, S[0]=1`. `delta=1`. `C=[1, -1]`. `L=1`.
2. `i=1, S[1]=1`. `delta=1-1=0`. `b=2`.
3. `i=2, S[2]=2`. `delta=2-1=1`. `C=[1, -1, -1]`. `L=2`.
   - Recurrence: `S_n = S_n-1 + S_n-2`.
4. `i=3, S[3]=3`. `delta=3-2-1=0`.
5. `i=4, S[4]=5`. `delta=5-3-2=0`.
6. `i=5, S[5]=8`. `delta=8-5-3=0`.

Final Recurrence: `S_n = S_n-1 + S_n-2`.
Target `n=10`.
Using Kitamasa/Matrix Exp, we get `S_10 = 89`.

![Example Visualization](../images/MTH-010/example-1.png)

## ‚úÖ Proof of Correctness

### Invariant
The algorithm maintains the shortest linear recurrence that satisfies the sequence up to index `i`.
If a discrepancy occurs, it updates the recurrence using the previous best recurrence to cancel out the error while minimizing the degree increase.

### Why the approach is correct
- Proven by Berlekamp and Massey.
- Guaranteed to find the minimal polynomial if `2L <= m`.

## üí° Interview Extensions (High-Value Add-ons)

- **Extension 1:** Sparse Matrix Determinant.
  - *Hint:* Wiedemann's Algorithm uses Berlekamp-Massey on the sequence `u^T A^i v`.
- **Extension 2:** Polynomial GCD.
  - *Hint:* Related to Euclidean algorithm.
- **Extension 3:** Predict next term.
  - *Hint:* Just run BM and apply recurrence once.

### Common Mistakes to Avoid

1. **Modulo Arithmetic**
   - ‚ùå Wrong: `C[idx] - val`.
   - ‚úÖ Correct: `(C[idx] - val + MOD) % MOD`.

2. **Base Cases**
   - ‚ùå Wrong: Ignoring `K=0` or `K=1`.
   - ‚úÖ Correct: Handle empty recurrence or single term recurrence.

## Related Concepts

- **Linear Feedback Shift Register (LFSR):** Hardware implementation.
- **Reed-Solomon Codes:** Error correction.
