<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AGR-011: Dinic With Scaling - Gamified</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Fraunces:wght@600;700&family=Space+Grotesk:wght@400;600;700&display=swap');

    :root {
      --bg: #f6f1e6;
      --ink: #1f2a33;
      --muted: #4f5b66;
      --accent: #e76f51;
      --accent-2: #2a9d8f;
      --accent-3: #264653;
      --card: #ffffff;
      --stroke: #e1d8c8;
      --shadow: 0 18px 40px rgba(31, 42, 51, 0.12);
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: 'Space Grotesk', sans-serif;
      color: var(--ink);
      background:
        radial-gradient(60% 80% at 10% 10%, rgba(231, 111, 81, 0.12), transparent 60%),
        radial-gradient(50% 70% at 90% 20%, rgba(42, 157, 143, 0.14), transparent 60%),
        linear-gradient(135deg, #f6f1e6 0%, #f1e9da 100%);
      min-height: 100vh;
      padding: 28px;
    }

    .shell {
      max-width: 1200px;
      margin: 0 auto;
      display: flex;
      flex-direction: column;
      gap: 24px;
    }

    header.hero {
      display: grid;
      grid-template-columns: 1.2fr 0.8fr;
      gap: 24px;
      background: var(--card);
      border-radius: 20px;
      box-shadow: var(--shadow);
      padding: 28px;
      border: 1px solid var(--stroke);
      animation: fadeUp 0.6s ease both;
    }

    .eyebrow {
      text-transform: uppercase;
      font-size: 0.8rem;
      letter-spacing: 0.22em;
      color: var(--muted);
      margin-bottom: 8px;
    }

    h1 {
      font-family: 'Fraunces', serif;
      font-size: 2.4rem;
      margin-bottom: 12px;
      line-height: 1.1;
    }

    .lead {
      font-size: 1.05rem;
      color: var(--muted);
      line-height: 1.6;
    }

    .hero-card {
      display: flex;
      flex-direction: column;
      gap: 16px;
      background: #fff9f0;
      border-radius: 18px;
      padding: 20px;
      border: 1px solid var(--stroke);
    }

    .badge-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .badge {
      padding: 6px 12px;
      border-radius: 999px;
      background: var(--accent-3);
      color: white;
      font-size: 0.85rem;
      font-weight: 600;
    }

    .tag {
      padding: 6px 12px;
      border-radius: 999px;
      background: #f2e7d7;
      color: var(--accent-3);
      font-size: 0.85rem;
      font-weight: 600;
      border: 1px solid var(--stroke);
    }

    .scenario {
      padding: 12px 14px;
      background: white;
      border-radius: 14px;
      border: 1px solid var(--stroke);
      color: var(--accent-3);
      font-weight: 600;
    }

    section {
      background: var(--card);
      border-radius: 20px;
      padding: 24px;
      border: 1px solid var(--stroke);
      box-shadow: var(--shadow);
      animation: fadeUp 0.6s ease both;
    }

    section:nth-of-type(2) { animation-delay: 0.06s; }
    section:nth-of-type(3) { animation-delay: 0.12s; }
    section:nth-of-type(4) { animation-delay: 0.18s; }
    section:nth-of-type(5) { animation-delay: 0.24s; }

    h2 {
      font-family: 'Fraunces', serif;
      font-size: 1.6rem;
      margin-bottom: 16px;
    }

    .grid-2 {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
      gap: 18px;
    }

    .rule-list {
      list-style: none;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .rule-list li {
      padding: 10px 12px;
      background: #f9f4eb;
      border-radius: 12px;
      border: 1px solid var(--stroke);
      line-height: 1.5;
    }

    .stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      gap: 14px;
      margin-top: 16px;
    }

    .stat {
      background: #fdf8ef;
      border-radius: 14px;
      padding: 12px 16px;
      border: 1px solid var(--stroke);
      text-align: center;
    }

    .stat .value {
      font-size: 1.4rem;
      font-weight: 700;
      color: var(--accent-3);
    }

    .stat .label {
      font-size: 0.85rem;
      color: var(--muted);
    }

    .game-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 20px;
      align-items: start;
    }

    .panel {
      background: #ffffff;
      border-radius: 16px;
      border: 1px solid var(--stroke);
      padding: 16px;
    }

    .panel h3 {
      font-size: 1.1rem;
      margin-bottom: 12px;
      color: var(--accent-3);
    }

    .step-bank,
    .step-track {
      display: grid;
      grid-template-columns: 1fr;
      gap: 8px;
    }

    .step-btn {
      border: 1px solid var(--stroke);
      background: #f7efe4;
      padding: 10px 12px;
      border-radius: 12px;
      cursor: pointer;
      text-align: left;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
      font-family: inherit;
      font-size: 0.95rem;
    }

    .step-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 10px 18px rgba(31, 42, 51, 0.12);
    }

    .step-btn.correct {
      background: #e9f7f2;
      border-color: #b9e6d5;
      color: var(--accent-2);
      cursor: default;
    }

    .step-slot {
      padding: 10px 12px;
      background: #f0f7f9;
      border-radius: 12px;
      border: 1px dashed #a9c6cf;
      color: var(--accent-3);
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-top: 12px;
    }

    .btn {
      padding: 10px 16px;
      border-radius: 999px;
      border: none;
      font-weight: 600;
      font-size: 0.9rem;
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }

    .btn.primary {
      background: var(--accent-3);
      color: white;
    }

    .btn.secondary {
      background: #f2e7d7;
      color: var(--accent-3);
      border: 1px solid var(--stroke);
    }

    .btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 10px 18px rgba(31, 42, 51, 0.12);
    }

    .message {
      margin-top: 12px;
      padding: 10px 12px;
      border-radius: 12px;
      background: #fff5e6;
      border: 1px solid #f0d9b5;
      color: #8a5b1f;
      font-size: 0.92rem;
      min-height: 20px;
    }

    .progress-bar {
      height: 12px;
      background: #f1e7da;
      border-radius: 999px;
      overflow: hidden;
      border: 1px solid var(--stroke);
      margin-top: 10px;
    }

    .progress-fill {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, var(--accent), var(--accent-2));
      transition: width 0.3s ease;
    }

    .quiz-card {
      border: 1px solid var(--stroke);
      border-radius: 14px;
      padding: 14px;
      background: #fffdf7;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .quiz-options {
      display: grid;
      gap: 8px;
    }

    .quiz-btn {
      border: 1px solid var(--stroke);
      background: white;
      border-radius: 10px;
      padding: 8px 10px;
      text-align: left;
      cursor: pointer;
      font-family: inherit;
      transition: background 0.2s ease, border 0.2s ease;
    }

    .quiz-btn.correct {
      background: #eaf6ed;
      border-color: #b9e6c1;
      color: #2f6f3c;
    }

    .quiz-btn.wrong {
      background: #fdeceb;
      border-color: #f3b5af;
      color: #a53f35;
    }

    .quiz-explain {
      font-size: 0.9rem;
      color: var(--muted);
    }

    .facts {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 12px;
    }

    .fact {
      background: #f7efe4;
      border-radius: 14px;
      padding: 12px 14px;
      border: 1px solid var(--stroke);
    }

    .fact-label {
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: var(--muted);
      margin-bottom: 6px;
    }

    .fact-value {
      font-weight: 700;
      color: var(--accent-3);
      font-size: 1rem;
      line-height: 1.4;
    }

    footer {
      text-align: center;
      color: var(--muted);
      font-size: 0.95rem;
      padding-bottom: 10px;
    }

    @keyframes fadeUp {
      from { opacity: 0; transform: translateY(12px); }
      to { opacity: 1; transform: translateY(0); }
    }

    @media (max-width: 900px) {
      header.hero {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <div class="shell">
    <header class="hero">
      <div>
        <div class="eyebrow">Advanced Graphs Gamified</div>
        <h1>AGR-011: Dinic With Scaling</h1>
        <p class="lead">Compute maximum flow faster by applying capacity scaling to Dinic.</p>
      </div>
      <div class="hero-card">
        <div class="badge-row">
          <span class="badge">Difficulty: Medium</span>
        </div>
        <div class="badge-row"><span class="tag">Graphs</span><span class="tag">Max Flow</span><span class="tag">Scaling</span></div>
        <div class="scenario">Scenario: The Campus 4K Streaming Crisis</div>
      </div>
    </header>

    <section>
      <h2>Mission Brief</h2>
      <div class="grid-2">
        <div>
          <p class="lead"><strong>Objective:</strong> Process large capacities with scaling phases to speed up max flow.</p>
          <div class="stats">
            <div class="stat">
              <div class="value" id="score">0</div>
              <div class="label">Score</div>
            </div>
            <div class="stat">
              <div class="value" id="streak">0</div>
              <div class="label">Streak</div>
            </div>
            <div class="stat">
              <div class="value" id="stepsDone">0 / 0</div>
              <div class="label">Steps Locked</div>
            </div>
            <div class="stat">
              <div class="value" id="quizScore">0 / 0</div>
              <div class="label">Quiz Correct</div>
            </div>
          </div>
          <div class="progress-bar">
            <div class="progress-fill" id="progressFill"></div>
          </div>
        </div>
        <div>
          <h3>Rules of the Arena</h3>
          <ul class="rule-list"><li>Graph is directed with large capacities.</li><li>Only consider edges with capacity &gt;= delta per phase.</li><li>Halve delta until it reaches 1.</li></ul>
        </div>
      </div>
    </section>

    <section>
      <h2>Step Sprint</h2>
      <div class="game-grid">
        <div class="panel">
          <h3>Step Bank</h3>
          <div class="step-bank" id="stepBank"></div>
          <div class="controls">
            <button class="btn primary" id="shuffleSteps">Shuffle Steps</button>
            <button class="btn secondary" id="resetScore">Reset Score</button>
          </div>
          <div class="message" id="stepMessage">Pick the first step in the algorithm.</div>
        </div>
        <div class="panel">
          <h3>Locked Sequence</h3>
          <div class="step-track" id="stepTrack"></div>
        </div>
      </div>
    </section>

    <section>
      <h2>Quick Quiz</h2>
      <div class="grid-2" id="quizContainer"></div>
    </section>

    <section>
      <h2>Algorithm Snapshot</h2>
      <div class="facts"><div class="fact"><div class="fact-label">Technique</div><div class="fact-value">Dinic with capacity scaling</div></div><div class="fact"><div class="fact-label">Time</div><div class="fact-value">O(E V log U) approx</div></div><div class="fact"><div class="fact-label">Space</div><div class="fact-value">O(V + E)</div></div></div>
    </section>

    <footer>Tip: Apply the delta filter in BFS and DFS, not in the graph itself.</footer>
  </div>

  <script>
    const gameData = {"id": "AGR-011", "steps": ["Set delta to the highest power of two <= max capacity.", "Build level graph using edges with cap >= delta.", "Send blocking flows under the delta filter.", "Halve delta and repeat."], "quiz": [{"q": "Delta represents what in scaling?", "options": ["Current capacity threshold", "Node count", "Edge count", "Distance limit"], "answer": 0, "explain": "Only edges with residual capacity above delta are used."}, {"q": "Why does scaling help?", "options": ["Large capacities are handled first with fewer phases", "It removes BFS", "It avoids residual graphs", "It eliminates edges"], "answer": 0, "explain": "Filtering by delta reduces work on small residual edges."}, {"q": "When do we stop scaling?", "options": ["When delta becomes 1", "After one BFS", "When graph is DAG", "When source equals sink"], "answer": 0, "explain": "The final phase with delta 1 covers all remaining capacity."}]};

    const state = {
      score: 0,
      streak: 0,
      stepsDone: 0,
      quizCorrect: 0,
      answered: new Set()
    };

    const scoreEl = document.getElementById('score');
    const streakEl = document.getElementById('streak');
    const stepsDoneEl = document.getElementById('stepsDone');
    const quizScoreEl = document.getElementById('quizScore');
    const progressFill = document.getElementById('progressFill');
    const stepBank = document.getElementById('stepBank');
    const stepTrack = document.getElementById('stepTrack');
    const stepMessage = document.getElementById('stepMessage');
    const quizContainer = document.getElementById('quizContainer');

    function shuffle(list) {
      for (let i = list.length - 1; i > 0; i -= 1) {
        const j = Math.floor(Math.random() * (i + 1));
        const tmp = list[i];
        list[i] = list[j];
        list[j] = tmp;
      }
      return list;
    }

    function updateStats() {
      scoreEl.textContent = state.score;
      streakEl.textContent = state.streak;
      stepsDoneEl.textContent = state.stepsDone + ' / ' + gameData.steps.length;
      quizScoreEl.textContent = state.quizCorrect + ' / ' + gameData.quiz.length;
      const progress = gameData.steps.length === 0 ? 0 : (state.stepsDone / gameData.steps.length) * 100;
      progressFill.style.width = progress + '%';
    }

    function resetScore() {
      state.score = 0;
      state.streak = 0;
      updateStats();
    }

    function renderSteps() {
      state.stepsDone = 0;
      stepBank.innerHTML = '';
      stepTrack.innerHTML = '';
      stepMessage.textContent = 'Pick the first step in the algorithm.';

      const bankItems = gameData.steps.map((text, index) => ({ text, index }));
      shuffle(bankItems);

      bankItems.forEach((item) => {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'step-btn';
        btn.textContent = item.text;
        btn.addEventListener('click', () => handleStepClick(item, btn));
        stepBank.appendChild(btn);
      });

      updateStats();
    }

    function handleStepClick(item, btn) {
      if (btn.classList.contains('correct')) {
        return;
      }

      if (item.index === state.stepsDone) {
        state.stepsDone += 1;
        state.score += 10;
        state.streak += 1;
        btn.classList.add('correct');
        btn.disabled = true;

        const slot = document.createElement('div');
        slot.className = 'step-slot';
        slot.textContent = item.text;
        stepTrack.appendChild(slot);

        if (state.stepsDone === gameData.steps.length) {
          stepMessage.textContent = 'Sequence complete. Nice work.';
          state.score += 20;
        } else {
          stepMessage.textContent = 'Good. Lock the next step.';
        }
      } else {
        state.streak = 0;
        state.score = Math.max(0, state.score - 5);
        stepMessage.textContent = 'Not yet. Look for the earliest missing step.';
      }

      updateStats();
    }

    function renderQuiz() {
      quizContainer.innerHTML = '';
      state.answered.clear();
      state.quizCorrect = 0;

      gameData.quiz.forEach((item, idx) => {
        const card = document.createElement('div');
        card.className = 'quiz-card';

        const question = document.createElement('div');
        question.className = 'quiz-q';
        question.textContent = 'Q' + (idx + 1) + '. ' + item.q;

        const options = document.createElement('div');
        options.className = 'quiz-options';

        const explain = document.createElement('div');
        explain.className = 'quiz-explain';

        item.options.forEach((optionText, optionIdx) => {
          const btn = document.createElement('button');
          btn.type = 'button';
          btn.className = 'quiz-btn';
          btn.textContent = optionText;
          btn.addEventListener('click', () => handleQuizClick(idx, optionIdx, btn, options, explain));
          options.appendChild(btn);
        });

        card.appendChild(question);
        card.appendChild(options);
        card.appendChild(explain);
        quizContainer.appendChild(card);
      });

      updateStats();
    }

    function handleQuizClick(qIndex, optionIdx, btn, options, explain) {
      if (state.answered.has(qIndex)) {
        return;
      }
      state.answered.add(qIndex);

      const item = gameData.quiz[qIndex];
      const buttons = options.querySelectorAll('button');
      buttons.forEach((button) => {
        button.disabled = true;
      });

      if (optionIdx === item.answer) {
        btn.classList.add('correct');
        state.score += 15;
        state.quizCorrect += 1;
        explain.textContent = item.explain;
      } else {
        btn.classList.add('wrong');
        state.score = Math.max(0, state.score - 5);
        explain.textContent = 'Correct: ' + item.options[item.answer] + '. ' + item.explain;
      }

      updateStats();
    }

    document.getElementById('shuffleSteps').addEventListener('click', renderSteps);
    document.getElementById('resetScore').addEventListener('click', resetScore);

    renderSteps();
    renderQuiz();
  </script>
</body>
</html>
