problem_id: BIT_MAX_SUBARRAY_XOR_START__8405
display_id: BIT-005
slug: max-subarray-xor-with-start
questions:
  - question: What is the XOR of subarray [6, 2, 8] from array [3, 6, 2, 8, 1]?
    difficulty: easy
    points: 10
    options:
      - "16"
      - "12"
      - "8"
      - "4"
    correct_answer: 1
    explanation: XOR of [6, 2, 8] = 6 ⊕ 2 ⊕ 8 = 4 ⊕ 8 = 12.
    type: single_choice
    id: prq_1
  - question: What is the purpose of inserting 0 into the Trie before processing the array?
    difficulty: easy
    points: 10
    options:
      - To handle the empty array case
      - To allow single-element subarrays (prefix ⊕ 0 = prefix)
      - To initialize the Trie structure
      - To optimize memory usage
    correct_answer: 1
    explanation: Inserting 0 (empty prefix) allows us to consider subarrays starting from index 0. For example, prefix[3] ⊕ 0 gives XOR of subarray [0..3].
    type: single_choice
    id: edq_1
  - question: Given prefix XOR array [0, 3, 5, 7], what is the XOR of subarray from index 1 to 2?
    difficulty: medium
    points: 15
    options:
      - "5"
      - "6"
      - "3"
      - "2"
    correct_answer: 1
    explanation: XOR(1,2) = prefix[2] ⊕ prefix[0] = 5 ⊕ 3 = 6. This represents arr[1] ⊕ arr[2].
    type: single_choice
    id: edq_2
  - question: Which operations are O(B) in the Trie-based solution where B is the number of bits? (Select all that apply)
    difficulty: medium
    points: 15
    options:
      - Inserting a number into the Trie
      - Querying maximum XOR for a number
      - Computing prefix XOR
      - Initializing the Trie
    correct_answer: 0
    explanation: Both insert and query traverse B bits from MSB to LSB, taking O(B) time. Computing prefix XOR is O(1) (single XOR operation). Initializing creates a root node, which is O(1).
    type: single_choice
    id: edq_3
