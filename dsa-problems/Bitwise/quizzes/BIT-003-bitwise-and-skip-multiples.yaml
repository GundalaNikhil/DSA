problem_id: BIT_AND_SKIP_MULTIPLES__8403
display_id: BIT-003
slug: bitwise-and-skip-multiples
questions:
  - question: What does it mean for index i to be 'bad' in this problem?
    difficulty: easy
    points: 10
    options:
      - arr[i] is negative
      - i is a multiple of some arr[j] where j < i
      - arr[i] is prime
      - i is even
    correct_answer: 1
    explanation: An index i is 'bad' if there exists some earlier index j (j < i) such that i is a multiple of arr[j]. These indices are skipped in the bitwise AND calculation.
    type: single_choice
    id: prq_1
  - question: For array [2, 3, 5] with k=7, which indices are 'bad'?
    difficulty: easy
    points: 10
    options:
      - 0, 1, 2
      - 2, 4, 6
      - 4, 6
      - None
    correct_answer: 2
    explanation: Index 2 is a multiple of arr[0]=2. Index 4 is a multiple of arr[0]=2. Index 6 is a multiple of both arr[0]=2 and arr[1]=3. So indices 2, 4, 6 are bad.
    type: single_choice
    id: edq_1
  - question: What is the bitwise AND of 7 and 5?
    difficulty: easy
    points: 10
    options:
      - "2"
      - "5"
      - "7"
      - "12"
    correct_answer: 1
    explanation: "7 & 5 = 111 & 101 = 101 = 5. Actually, wait: 111 & 101 = 101 = 5. Let me recalculate: 111 & 101 = 101 = 5. Hmm, that's 5, not 2. Let me recalculate properly: 7=111, 5=101, 111&101=101=5."
    type: single_choice
    id: edq_2
  - question: Which properties of bitwise AND are useful for this problem? (Select all that apply)
    difficulty: medium
    points: 15
    options:
      - AND with 0 gives 0
      - "AND is commutative: a&b = b&a"
      - "AND is associative: (a&b)&c = a&(b&c)"
      - AND preserves only common set bits
    correct_answer: 1
    explanation: AND is commutative and associative (order doesn't matter). It preserves only bits that are 1 in all operands. AND with 0 gives 0, but we're not ANDing with 0 in this problem's core logic.
    type: single_choice
    id: edq_3
