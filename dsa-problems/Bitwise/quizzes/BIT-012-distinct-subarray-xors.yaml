problem_id: BIT_DISTINCT_SUBARRAY_XORS__8412
display_id: BIT-012
slug: distinct-subarray-xors
questions:
  - question: "How many total subarrays exist in an array of length n?

      "
    difficulty: easy
    points: 10
    options:
      - n
      - n²
      - n(n+1)/2
      - 2^n
    correct_answer: 2
    explanation: "For each starting position i (n choices) and ending position j ≥ i (n-i choices), \ntotal = Σ(i=0 to n-1) (n-i) = n(n+1)/2.\n"
    type: single_choice
    id: prq_1
  - question: "What data structure efficiently tracks distinct XOR values?

      "
    difficulty: easy
    points: 10
    options:
      - Array
      - Set/HashSet
      - Stack
      - Queue
    correct_answer: 1
    explanation: "Set/HashSet automatically handles uniqueness by not allowing duplicates, \nperfect for counting distinct values.\n"
    type: single_choice
    id: edq_1
  - question: "For array [1, 2, 3], what is the XOR of subarray [1, 2]?

      "
    difficulty: medium
    points: 15
    options:
      - "1"
      - "2"
      - "3"
      - "0"
    correct_answer: 2
    explanation:
      "Subarray [1, 2] has elements 1 and 2. XOR = 1 ^ 2 = 001 ^ 010 = 011 = 3.

      "
    type: single_choice
    id: edq_2
  - question: "Which approaches can solve this problem?

      "
    difficulty: medium
    points: 15
    options:
      - Generate all subarrays with nested loops
      - Use prefix XOR array
      - Use Trie for optimization
      - Sort the array first
    correct_answer: 0
    explanation: "Nested loops (correct) and prefix XOR (correct) both work in O(n²). \nTrie doesn't provide benefits for counting distinct values. Sorting changes the problem.\n"
    type: single_choice
    id: edq_3
