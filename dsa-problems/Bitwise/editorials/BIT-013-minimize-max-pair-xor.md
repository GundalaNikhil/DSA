---
problem_id: BIT_MINIMIZE_MAX_PAIR_XOR__8413
display_id: BIT-013
slug: minimize-max-pair-xor
title: "Minimize the Maximum of Pair XORs"
difficulty: Hard
difficulty_score: 85
topics:
  - Bitwise Operations
  - Dynamic Programming
  - Bitmask
tags:
  - bitwise
  - dp-bitmask
  - hard
  - optimization
premium: true
subscription_tier: basic
---

# BIT-013: Minimize the Maximum of Pair XORs

## ðŸ“‹ Problem Summary

Given an array of `2N` integers, pair them up into `N` pairs such that the **maximum** XOR sum among all pairs is **minimized**.
Constraint: $2N \le 16$ or similar small constraint allowing exponential complexity.

## ðŸŒ Real-World Scenario

**Scenario Title:** The Radio Frequency Plan ðŸ“»

### The Problem
You are setting up radio links for a remote expedition.
-   **Radios:** You have `2N` radio units. Each unit operates at a specific base frequency `a[i]`.
-   **Links:** You must pair the radios together to form `N` communication links.
-   **Interference:** The interference generated by a link is the XOR difference of their frequencies: `Freq1 ^ Freq2`.
-   **Constraint:** The whole system is only as good as its weakest (noisiest) link. If any single link has massive interference, it disrupts the network.
-   **Goal:** Pair the radios such that the **worst** link's interference is as low as possible. (Minimize the Maximum XOR).

![Real-World Application](../images/BIT-013/real-world-scenario.png)

### From Real World to Algorithm
-   **Pairing:** We need to form a perfect matching.
-   **Optimization:** $\min_{\text{matchings}} (\max_{(u, v) \in \text{matching}} (u \oplus v))$.
-   **Small N:** Since pairing is combinatorial, and $N$ is small, we can use recursion with state memorization.
-   **State:** A bitmask representing which radios have already been paired.

## Detailed Explanation

### logical Diagram: Recursive Choices

**Input:** `[10, 20, 30, 40]`
**State `0000` (None used):**
-   Pick first available (Index 0: `10`).
-   **Option A:** Pair `10` with `20` (Index 1).
    -   Cost: `10^20 = 30`.
    -   Remaining: `{30, 40}` -> Pair `30` with `40`. Cost `30^40 = 54`.
    -   Max: `54`.
-   **Option B:** Pair `10` with `30` (Index 2).
    -   Cost: `10^30 = 20`.
    -   Remaining: `{20, 40}` -> Pair `20` with `40`. Cost `20^40 = 60`.
    -   Max: `60`.
-   **Option C:** Pair `10` with `40` (Index 3).
    -   Cost: `10^40 = 34`.
    -   Remaining: `{20, 30}` -> Pair `20` with `30`. Cost `20^30 = 10`.
    -   Max: `34`.

**Winner:** Option C (Max 34).

```mermaid
graph TD
    Start[State: 0000] --> PickFirst[Pick i=0]
    PickFirst --> TryJ1[Pair with j=1]
    PickFirst --> TryJ2[Pair with j=2]
    PickFirst --> TryJ3[Pair with j=3]
    TryJ1 --> Rec1[Recurse: 1100]
    TryJ2 --> Rec2[Recurse: 1010]
    TryJ3 --> Rec3[Recurse: 1001]
    Rec1 --> Res1[Max(30, 54)=54]
    Rec2 --> Res2[Max(20, 60)=60]
    Rec3 --> Res3[Max(34, 10)=34]
    Res1 --> Compare
    Res2 --> Compare
    Res3 --> Compare
    Compare --> Min[Result: 34]
```

## âœ… Input/Output Clarifications
-   **Input:** Array `a` (Even length).
-   **Output:** Integer.

## Naive Approach (All Permutations)
Generate all matchings.
-   **Time:** Factorial-ish.

## Optimal Approach (DP with Bitmask)

### Algorithm
1.  **Function `solve(mask)`:** Returns min-max XOR for the subset of unused elements (0 bits in mask).
2.  **Base Case:** If mask is full (all 1s), return 0.
3.  **Recursion:**
    -   Find the first unset bit `i` (index of first available radio).
    -   Iterate `j` from `i+1` to `N-1`.
    -   If `j` is also unset:
        -   Try pairing `(i, j)`.
        -   `Cost = max(a[i] ^ a[j], solve(mask | (1<<i) | (1<<j)))`.
        -   Keep `min` of all costs.
4.  **Memoization:** Store result for `mask`.

### Time Complexity
-   **O(N \cdot 2^{2N})**.
-   **Space:** $O(2^{2N})$.

## Implementations

### Java
```java
import java.util.*;

class Solution {
    int n;
    int[] a;
    Integer[] memo;

    public int minimizeMaxPairXor(int[] a) {
        this.n = a.length;
        this.a = a;
        this.memo = new Integer[1 << n];
        return solve(0);
    }

    private int solve(int mask) {
        if (mask == (1 << n) - 1) return 0;
        if (memo[mask] != null) return memo[mask];

        // Find match for the first available number
        int i = 0;
        while (((mask >> i) & 1) == 1) i++;

        int res = Integer.MAX_VALUE;

        // Pair i with any other available j
        for (int j = i + 1; j < n; j++) {
            if (((mask >> j) & 1) == 0) {
                int pairXor = a[i] ^ a[j];
                int remMax = solve(mask | (1 << i) | (1 << j));
                res = Math.min(res, Math.max(pairXor, remMax));
            }
        }
        return memo[mask] = res;
    }
}
```

### Python
```python
def minimize_max_pair_xor(a: list[int]) -> int:
    n = len(a)
    memo = {}

    def solve(mask):
        if mask == (1 << n) - 1:
            return 0
        if mask in memo:
            return memo[mask]
        
        # Find first unset bit
        i = 0
        while (mask >> i) & 1:
            i += 1
            
        res = float('inf')
        
        for j in range(i + 1, n):
            if not ((mask >> j) & 1):
                pair_xor = a[i] ^ a[j]
                rem_max = solve(mask | (1 << i) | (1 << j))
                res = min(res, max(pair_xor, rem_max))
        
        memo[mask] = res
        return res

    return solve(0)
```

### C++
```cpp
#include <vector>
#include <algorithm>
#include <climits>
using namespace std;

class Solution {
    int n;
    vector<int> a;
    vector<int> memo;

public:
    int minimizeMaxPairXor(vector<int>& a) {
        this->n = a.size();
        this->a = a;
        memo.assign(1 << n, -1);
        return solve(0);
    }

    int solve(int mask) {
        if (mask == (1 << n) - 1) return 0;
        if (memo[mask] != -1) return memo[mask];
        
        int i = 0;
        while ((mask >> i) & 1) i++;
        
        int res = INT_MAX;
        
        for (int j = i + 1; j < n; j++) {
            if (!((mask >> j) & 1)) {
                int pairXor = a[i] ^ a[j];
                int remMax = solve(mask | (1 << i) | (1 << j));
                res = min(res, max(pairXor, remMax));
            }
        }
        return memo[mask] = res;
    }
};
```

### JavaScript
```javascript
class Solution {
  minimizeMaxPairXor(a) {
    const n = a.length;
    const memo = new Map();

    const solve = (mask) => {
        if (mask === (1 << n) - 1) return 0;
        if (memo.has(mask)) return memo.get(mask);
        
        let i = 0;
        while ((mask >> i) & 1) i++;
        
        let res = Infinity;
        
        for (let j = i + 1; j < n; j++) {
            if (!((mask >> j) & 1)) {
                const pairXor = a[i] ^ a[j];
                const remMax = solve(mask | (1 << i) | (1 << j));
                res = Math.min(res, Math.max(pairXor, remMax));
            }
        }
        memo.set(mask, res);
        return res;
    };
    return solve(0);
  }
}
```

## ðŸ§ª Test Case Walkthrough
Same as logic diagram. `[10, 20, 30, 40]`. Result 34.

## âœ… Proof of Correctness
We systematically explore pairing `a[i]` with every other possible `a[j]`. Since we always pick the *lowest index* `i` first, we avoid duplicate permutations (we don't check `(j, i)` separate from `(i, j)`). This is standard Bitmask DP for matching problems.

## ðŸ’¡ Interview Extensions
1.  **Greedy?** Sorting or Trie doesn't work easily for Min-Max.
2.  **General Matching:** Weighted Perfect Matching.
