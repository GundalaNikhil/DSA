---
problem_id: BIT_SMALLEST_ABSENT_XOR__8409
display_id: BIT-009
slug: smallest-absent-xor
title: "Smallest Absent XOR"
difficulty: Medium
difficulty_score: 60
topics:
  - Bitwise Operations
  - XOR
  - XOR Basis
  - Linear Algebra
tags:
  - bitwise
  - xor
  - xor-basis
  - hard
  - medium
premium: true
subscription_tier: basic
---

# BIT-009: Smallest Absent XOR

## ðŸ“‹ Problem Summary

You are given a list of numbers. You can choose any subset of these numbers and XOR them together to create a new value. This forms a "set of reachable values". Find the **smallest non-negative integer** that is **NOT** in this set.
(Note: The value 0 is always reachable by choosing an empty subset).

## ðŸŒ Real-World Scenario

**Scenario Title:** The Glitched Game Leaderboard ðŸŽ®

### The Problem
You are testing a video game with a "Fusion" mechanics.
-   **Items:** You have an inventory of artifacts, each with a magic Power ID `A[i]`.
-   **Fusion:** You can combine any number of artifacts. The resulting Power ID is the **XOR sum** of the ingredients.
-   **Bug Bounty:** The developers claim "You can create any Power ID from 0 to MAX!".
-   **Your Job:** Prove them wrong. Find the **smallest Power ID** that is mathematically **impossible** to create using your current inventory. This is the "First Gap" in the game's possibility space.

![Real-World Application](../images/BIT-009/real-world-scenario.png)

### From Real World to Algorithm
-   **Vector Space:** The set of values generated by XORing subsets forms a "Linear Vector Space" over the field GF(2).
-   **Structure:** This space is highly structured. You can't just miss a random number like "3" if you can make "1" and "2" (because $1 \oplus 2 = 3$).
-   **The Gap:** If you can form all numbers from $0$ to $2^k - 1$, and you cannot form $2^k$, then $2^k$ is the smallest missing number.
-   **Theorem:** The smallest missing XOR sum is **always** a power of 2 ($1, 2, 4, 8, \dots$).

## Detailed Explanation

### logical Diagram: The Basis Ladder

Imagine building a ladder to reach numbers.
-   Bit 0 (1s): Do we have a number that can flip the 1st bit? Yes/No.
-   Bit 1 (2s): Do we have a number that can flip the 2nd bit? Yes/No.

**Example:** `[10 (1010), 5 (0101)]`
1.  **Bit 3 (8s):** `10` uses bit 3. We keep `10` as the "Key" for Bit 3.
2.  **Bit 2 (4s):** `5` uses bit 2. We keep `5` as the "Key" for Bit 2.
3.  **Bit 1 (2s):** Can we make just `2` (`0010`)?
    -   `10` has bit 1. But it brings bit 3 with it.
    -   `5` has no bit 1.
    -   We cannot isolate Bit 1.
    -   Thus, we cannot form `2`.
4.  **Bit 0 (1s):** Can we make just `1` (`0001`)?
    -   `5` has bit 0. `5 = 4 + 1`.
    -   To isolate `1`, we need to cancel the `4`. We have `5`. We need a `4`. We don't have a clean `4`.
    -   (Actually, checking powers of 2 is simpler).

**Algorithm Logic:**
Check minimal powers of 2:
-   Can we make **1** ($2^0$)?
    -   We need a basis element controlling Bit 0.
    -   If we *don't* have a basis vector for Bit 0, we can never flip the last bit independently. Since all basis vectors have LSB=0, all XOR sums will have LSB=0 (Even numbers). Thus, **1 (Odd)** is impossible.
-   Can we make **2** ($2^1$)?
    -   If we have Basis[0]... but missing Basis[1]? Then we can't toggle Bit 1 independently.

```mermaid
graph TD
    Start[Input Array] --> Build[Build Linear Basis]
    Build --> Loop[Check Basis indices 0, 1, 2...]
    Loop --> Check{Is Basis[i] Empty?}
    Check -- Yes --> Found[Return 2^i]
    Check -- No --> Next[Check Basis[i+1]]
    Next --> Loop
```

## âœ… Input/Output Clarifications
-   **Input:** Array `a` (up to $10^5$ elements).
-   **Output:** The smallest missing integer.
-   **Note:** It will effectively be $2^k$, where $k$ is the index of the first missing basis vector.

## Naive Approach (Generate All Subsets)
Recursively generate all $2^N$ sums. Store in a HashSet. Check 1, 2, 3...
-   **Time:** $O(2^N)$. Impossible for $N > 20$.
-   **Space:** Huge.

## Optimal Approach (Gaussian Elimination / Linear Basis)

### Algorithm
1.  **Basis Construction:** We want to find a minimal set of numbers (Basis) that can form the same XOR values as the original array. The Bias has size at most 30 (for 32-bit integers).
2.  **Insertion:** For every number `x` in the array:
    -   Scan bits from high (30) to low (0).
    -   If `x` has bit `i` set:
        -   If `Basis[i]` is empty: Store `Basis[i] = x`. Break. (This number is now the "Key" for bit `i`).
        -   If `Basis[i]` is present: `x = x ^ Basis[i]`. (Cancel out bit `i` using the existing key and continue).
3.  **Search:**
    -   Iterate `i` from 0 to 30.
    -   If `Basis[i]` is empty, it means we cannot control bit `i` independently of higher bits.
    -   Because we reduced the basis, "cannot control bit `i`" specifically means we cannot form the value $2^i$. (Any combination of higher basis vectors results in a value $\ge 2^{i+1}$).
    -   Return $2^i$.

### Time Complexity
-   **O(N * 30)**: We process each of N numbers, doing at most 30 XOR operations.
-   **Space:** $O(30)$ to store the base.

## Implementations

### Java
```java
import java.util.*;

class Solution {
    public long smallestAbsentXor(int[] a) {
        int[] basis = new int[32];
        
        // 1. Build Linear Basis
        for (int x : a) {
            for (int i = 30; i >= 0; i--) {
                // If bit i is set
                if (((x >> i) & 1) == 1) {
                    if (basis[i] == 0) {
                        // Found a new basis vector for bit i
                        basis[i] = x;
                        break;
                    }
                    // XOR with existing basis to cancel bit i
                    x ^= basis[i];
                }
            }
        }
        
        // 2. Find first missing basis vector
        for (int i = 0; i <= 30; i++) {
            if (basis[i] == 0) {
                return (1L << i);
            }
        }
        
        return (1L << 31);
    }
}
```

### Python
```python
def smallest_absent_xor(a: list[int]) -> int:
    basis = [0] * 32
    
    # 1. Build Basis
    for x in a:
        for i in range(30, -1, -1):
            if (x >> i) & 1:
                if basis[i] == 0:
                    basis[i] = x
                    break
                x ^= basis[i]
                
    # 2. Find Gap
    for i in range(31):
        if basis[i] == 0:
            return 1 << i
            
    return 1 << 31
```

### C++
```cpp
#include <vector>
using namespace std;

class Solution {
public:
    long long smallestAbsentXor(vector<int>& a) {
        vector<int> basis(32, 0);
        
        // 1. Build Basis
        for (int x : a) {
            for (int i = 30; i >= 0; i--) {
                if ((x >> i) & 1) {
                    if (basis[i] == 0) {
                        basis[i] = x;
                        break;
                    }
                    x ^= basis[i];
                }
            }
        }
        
        // 2. Find Gap
        for (int i = 0; i <= 30; i++) {
            if (basis[i] == 0) {
                return (1LL << i);
            }
        }
        return (1LL << 31);
    }
};
```

### JavaScript
```javascript
class Solution {
  smallestAbsentXor(a) {
    const basis = new Int32Array(32);
    
    for (let x of a) {
      for (let i = 30; i >= 0; i--) {
        if ((x >>> i) & 1) {
          if (basis[i] === 0) {
            basis[i] = x;
            break;
          }
          x ^= basis[i];
        }
      }
    }
    
    for (let i = 0; i <= 30; i++) {
      if (basis[i] === 0) {
        // Use BigInt for safe large number return
        return (1n << BigInt(i)).toString();
      }
    }
    return (1n << 31n).toString();
  }
}
```

## ðŸ§ª Test Case Walkthrough

**Input:** `[1, 2, 3]`
1.  **Process 1 (`01`):** Bit 0 set. `Basis[0]=1`.
2.  **Process 2 (`10`):** Bit 1 set. `Basis[1]=2`.
3.  **Process 3 (`11`):**
    -   Bit 1 set. `Basis[1]` exists (2). `3 ^ 2 = 1`.
    -   Bit 0 set. `Basis[0]` exists (1). `1 ^ 1 = 0`.
    -   Becomes 0. Ignore.
**Check Gap:**
-   `Basis[0]` (1) exists? Yes.
-   `Basis[1]` (2) exists? Yes.
-   `Basis[2]` (4) exists? **No**.
**Result:** $2^2 = 4$.

**Correction Note in Logic:**
Does `[1, 2]` make 3? Yes $1 \oplus 2=3$.
Values reachable: 0, 1, 2, 3.
Smallest missing: 4 ($2^2$).
The algorithm returns 4. Correct.

## âœ… Proof of Correctness
The set of reachable XOR sums forms a vector subspace. If the basis for bits $0, 1, \dots, k-1$ is fully populated, the subspace span covers all $2^k$ integers from $0$ to $2^k-1$. The first missing bit $k$ in the basis implies that we cannot introduce a "new" MSB at position $k$. No combination of lower bits can jump to $\ge 2^k$. Any combination of higher bits will result in values $\ge 2^{k+1}$ or reduce to lower bits. Thus, $2^k$ is strictly unreachable.

## ðŸ’¡ Interview Extensions
1.  **Count Reachable:** How many distinct values can be found? Answer: $2^{\text{basis size}}$.
2.  **Max XOR:** Use the same basis, try to flip 0s to 1s from MSB down.
