<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GEO-016: Euclidean MST</title>
    <link href="https://fonts.googleapis.com/css2?family=Rubik:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: 'Rubik', sans-serif;
            background: linear-gradient(135deg, #059669 0%, #34d399 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container { max-width: 900px; margin: 0 auto; }

        .header { text-align: center; color: #fff; margin-bottom: 20px; }
        .header h1 { font-size: 32px; }

        .tutorial {
            background: #fff;
            border-radius: 16px;
            padding: 20px;
            margin-bottom: 20px;
        }
        .tutorial h2 { color: #059669; margin-bottom: 12px; }
        .tutorial p { font-size: 14px; color: #555; line-height: 1.6; }

        .game-card {
            background: #fff;
            border-radius: 16px;
            padding: 20px;
        }

        .info-bar {
            display: flex;
            justify-content: space-between;
            padding: 12px 18px;
            background: linear-gradient(90deg, #059669, #34d399);
            border-radius: 10px;
            color: #fff;
            margin-bottom: 15px;
        }

        .canvas-container {
            background: #f8fafc;
            border-radius: 12px;
            padding: 10px;
            margin-bottom: 15px;
        }
        canvas {
            display: block;
            margin: 0 auto;
            border-radius: 8px;
            cursor: pointer;
        }

        .cost-display {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-bottom: 15px;
        }
        .cost-item {
            text-align: center;
            padding: 15px 25px;
            background: #ecfdf5;
            border-radius: 10px;
        }
        .cost-label { font-size: 12px; color: #666; }
        .cost-value { font-size: 24px; font-weight: 600; color: #059669; }

        .controls {
            display: flex;
            gap: 10px;
            justify-content: center;
        }
        .btn {
            padding: 12px 25px;
            border: none;
            border-radius: 10px;
            font-family: inherit;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
        }
        .btn-check { background: #059669; color: #fff; }
        .btn-reveal { background: #f59e0b; color: #fff; }
        .btn-clear { background: #64748b; color: #fff; }
        .btn-new { background: #64748b; color: #fff; }
        .btn:hover { transform: scale(1.05); }

        .message {
            text-align: center;
            padding: 15px;
            border-radius: 10px;
            font-weight: 600;
            margin-top: 15px;
        }
        .message.correct { background: #d1fae5; color: #059669; }
        .message.wrong { background: #fee2e2; color: #dc2626; }
        .message.neutral { background: #ecfdf5; color: #047857; }

    </style>
</head>
<body>

<div class="container">
    <div class="header">
        <h1>üå≤ Euclidean MST Builder</h1>
        <div style="opacity:0.9">Connect all points with minimum total distance!</div>
    </div>

    <div class="tutorial">
        <h2>üìñ How to Play</h2>
        <p>Click two points to connect them with an edge. Build a Minimum Spanning Tree (MST) that connects all points with the smallest possible total distance. You need exactly N-1 edges for N points!</p>
    </div>

    <div class="game-card">
        <div class="info-bar">
            <span>Points: <strong id="numPoints">0</strong></span>
            <span>Edges: <strong id="numEdges">0</strong> / <span id="neededEdges">0</span></span>
        </div>

        <div class="canvas-container">
            <canvas id="canvas" width="500" height="400"></canvas>
        </div>

        <div class="cost-display">
            <div class="cost-item">
                <div class="cost-label">Your Cost</div>
                <div class="cost-value" id="yourCost">0</div>
            </div>
            <div class="cost-item">
                <div class="cost-label">Optimal MST</div>
                <div class="cost-value" id="optimalCost">?</div>
            </div>
        </div>

        <div class="controls">
            <button class="btn btn-check" onclick="checkMST()">‚úì Check</button>
            <button class="btn btn-reveal" onclick="revealMST()">üëÅ Reveal</button>
            <button class="btn btn-clear" onclick="clearEdges()">‚Ü∫ Clear</button>
            <button class="btn btn-new" onclick="newRound()">üîÑ New</button>
        </div>

        <div class="message neutral" id="message">Click two points to add an edge!</div>
    </div>
</div>

<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    let points = [];
    let userEdges = [];
    let selectedPoint = -1;
    let optimalMST = [];
    let optimalCost = 0;
    let revealed = false;

    function generatePoints() {
        points = [];
        userEdges = [];
        selectedPoint = -1;
        revealed = false;

        const numPoints = 5 + Math.floor(Math.random() * 3);
        const margin = 60;

        for (let i = 0; i < numPoints; i++) {
            points.push({
                x: margin + Math.random() * (canvas.width - margin * 2),
                y: margin + Math.random() * (canvas.height - margin * 2)
            });
        }

        computeOptimalMST();
    }

    function distance(i, j) {
        const dx = points[i].x - points[j].x;
        const dy = points[i].y - points[j].y;
        return Math.sqrt(dx * dx + dy * dy);
    }

    function computeOptimalMST() {
        // Prim's algorithm
        const n = points.length;
        const inMST = new Array(n).fill(false);
        const minEdge = new Array(n).fill(Infinity);
        const parent = new Array(n).fill(-1);

        minEdge[0] = 0;
        optimalMST = [];
        optimalCost = 0;

        for (let count = 0; count < n; count++) {
            let u = -1;
            for (let i = 0; i < n; i++) {
                if (!inMST[i] && (u === -1 || minEdge[i] < minEdge[u])) {
                    u = i;
                }
            }

            inMST[u] = true;
            if (parent[u] !== -1) {
                optimalMST.push([parent[u], u]);
                optimalCost += distance(parent[u], u);
            }

            for (let v = 0; v < n; v++) {
                const d = distance(u, v);
                if (!inMST[v] && d < minEdge[v]) {
                    minEdge[v] = d;
                    parent[v] = u;
                }
            }
        }
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Grid
        ctx.strokeStyle = '#e2e8f0';
        ctx.lineWidth = 1;
        for (let x = 0; x <= canvas.width; x += 50) {
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, canvas.height);
            ctx.stroke();
        }
        for (let y = 0; y <= canvas.height; y += 50) {
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(canvas.width, y);
            ctx.stroke();
        }

        // Draw user edges
        userEdges.forEach(([i, j]) => {
            ctx.beginPath();
            ctx.moveTo(points[i].x, points[i].y);
            ctx.lineTo(points[j].x, points[j].y);
            ctx.strokeStyle = '#059669';
            ctx.lineWidth = 3;
            ctx.stroke();

            // Show distance
            const mx = (points[i].x + points[j].x) / 2;
            const my = (points[i].y + points[j].y) / 2;
            ctx.fillStyle = '#059669';
            ctx.font = 'bold 10px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(distance(i, j).toFixed(0), mx, my - 5);
        });

        // Draw optimal MST if revealed
        if (revealed) {
            optimalMST.forEach(([i, j]) => {
                ctx.beginPath();
                ctx.moveTo(points[i].x, points[i].y);
                ctx.lineTo(points[j].x, points[j].y);
                ctx.strokeStyle = '#f59e0b';
                ctx.lineWidth = 3;
                ctx.setLineDash([8, 4]);
                ctx.stroke();
                ctx.setLineDash([]);
            });
        }

        // Draw points
        points.forEach((p, i) => {
            ctx.beginPath();
            ctx.arc(p.x, p.y, i === selectedPoint ? 14 : 10, 0, Math.PI * 2);
            ctx.fillStyle = i === selectedPoint ? '#f59e0b' : '#059669';
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 3;
            ctx.stroke();

            ctx.fillStyle = '#fff';
            ctx.font = 'bold 10px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(i + 1, p.x, p.y);
        });

        // Update info
        let yourCost = 0;
        userEdges.forEach(([i, j]) => yourCost += distance(i, j));

        document.getElementById('numPoints').textContent = points.length;
        document.getElementById('numEdges').textContent = userEdges.length;
        document.getElementById('neededEdges').textContent = points.length - 1;
        document.getElementById('yourCost').textContent = yourCost.toFixed(0);
        document.getElementById('optimalCost').textContent = revealed ? optimalCost.toFixed(0) : '?';
    }

    canvas.onclick = function(e) {
        if (revealed) return;
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        for (let i = 0; i < points.length; i++) {
            const dx = x - points[i].x;
            const dy = y - points[i].y;
            if (dx * dx + dy * dy < 400) {
                if (selectedPoint === -1) {
                    selectedPoint = i;
                } else if (selectedPoint === i) {
                    selectedPoint = -1;
                } else {
                    // Add edge if not already exists
                    const exists = userEdges.some(([a, b]) => 
                        (a === selectedPoint && b === i) || (a === i && b === selectedPoint)
                    );
                    if (!exists) {
                        userEdges.push([selectedPoint, i]);
                    }
                    selectedPoint = -1;
                }
                draw();
                break;
            }
        }
    };

    function clearEdges() {
        userEdges = [];
        selectedPoint = -1;
        draw();
        document.getElementById('message').className = 'message neutral';
        document.getElementById('message').textContent = 'Click two points to add an edge!';
    }

    function checkMST() {
        const n = points.length;
        if (userEdges.length !== n - 1) {
            document.getElementById('message').className = 'message wrong';
            document.getElementById('message').textContent = `Need exactly ${n-1} edges, you have ${userEdges.length}`;
            return;
        }

        // Check connectivity
        const adj = Array(n).fill().map(() => []);
        userEdges.forEach(([i, j]) => {
            adj[i].push(j);
            adj[j].push(i);
        });

        const visited = new Array(n).fill(false);
        const queue = [0];
        visited[0] = true;
        let count = 1;

        while (queue.length > 0) {
            const u = queue.shift();
            for (const v of adj[u]) {
                if (!visited[v]) {
                    visited[v] = true;
                    count++;
                    queue.push(v);
                }
            }
        }

        if (count !== n) {
            document.getElementById('message').className = 'message wrong';
            document.getElementById('message').textContent = 'Graph is not connected! All points must be reachable.';
            return;
        }

        let yourCost = 0;
        userEdges.forEach(([i, j]) => yourCost += distance(i, j));

        const diff = yourCost - optimalCost;
        const percent = (yourCost / optimalCost - 1) * 100;

        const msg = document.getElementById('message');
        if (percent <= 5) {
            msg.className = 'message correct';
            msg.textContent = `‚úÖ Excellent! Your MST cost is ${yourCost.toFixed(0)} (optimal: ${optimalCost.toFixed(0)})`;
        } else if (percent <= 20) {
            msg.className = 'message neutral';
            msg.textContent = `üëç Valid tree! Cost ${yourCost.toFixed(0)} is ${percent.toFixed(0)}% above optimal`;
        } else {
            msg.className = 'message wrong';
            msg.textContent = `‚ùå Valid but expensive! ${yourCost.toFixed(0)} vs optimal ${optimalCost.toFixed(0)}`;
        }
    }

    function revealMST() {
        revealed = true;
        draw();
        document.getElementById('message').className = 'message neutral';
        document.getElementById('message').textContent = `Optimal MST shown in orange (cost = ${optimalCost.toFixed(0)})`;
    }

    function newRound() {
        generatePoints();
        draw();
        document.getElementById('message').className = 'message neutral';
        document.getElementById('message').textContent = 'Click two points to add an edge!';
    }

    window.onload = newRound;
</script>
</body>
</html>
