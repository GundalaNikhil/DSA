<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ARR-005: Equilibrium Scale</title>
    <link href="https://fonts.googleapis.com/css2?family=Chakra+Petch:wght@400;700&family=Teko:wght@400;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg: #1e1e2e;
            --panel: #262a42;
            --beam: #a0a0b0;
            --border: #4a4e69;
            --text: #cdd6f4;
            --accent: #f9e2af;
            --danger: #f38ba8;
            --success: #a6e3a1;
            --highlight: #89b4fa;
        }

        body {
            font-family: 'Chakra Petch', sans-serif;
            background: var(--bg);
            color: var(--text);
            margin: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            user-select: none;
        }

        header {
            background: var(--panel);
            padding: 1rem 2rem;
            border-bottom: 2px solid var(--border);
            display: flex; justify-content: space-between; align-items: center;
        }

        h1 { margin:0; font-family:'Teko'; font-size:2rem; letter-spacing:2px; color:var(--highlight); }

        .param-badge {
            background: rgba(255,255,255,0.1); border-radius: 4px; padding: 5px 15px;
            font-family: 'Teko'; font-size: 1.2rem; display: flex; gap: 10px;
        }

        main {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 2rem;
            position: relative;
        }

        /* Scale Mechanism */
        .scale-container {
            width: 1000px;
            display: flex; flex-direction: column; align-items: center;
            position: relative;
            margin-top: 50px;
        }

        .beam-wrapper {
            position: relative;
            width: 100%;
            display: flex; justify-content: center;
            /* Rotation container */
            transition: transform 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            transform-origin: center bottom;
        }

        .beam {
            width: 900px; height: 10px;
            background: var(--beam);
            border-radius: 5px;
            position: relative;
            display: flex; justify-content: space-between; align-items: center;
            padding: 0 40px;
        }

        .weights-container {
            position: absolute; top: -60px; left: 0; width: 100%;
            display: flex; justify-content: space-around;
            padding: 0 40px; box-sizing: border-box;
        }

        .weight-box {
            width: 50px; height: 50px;
            background: #313244;
            border: 2px solid var(--border);
            border-radius: 8px;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }
        .weight-box:hover { border-color: var(--highlight); transform: translateY(-5px); }
        .weight-box.pivot { 
            background: var(--highlight); color: #1e1e2e; border-color: #fff;
            transform: scale(1.1); box-shadow: 0 0 20px var(--highlight);
            z-index: 10;
        }
        
        /* Fulcrum Triangle */
        .fulcrum-track {
            width: 900px; height: 40px;
            margin-top: 5px;
            position: relative;
        }
        .fulcrum {
            width: 0; height: 0;
            border-left: 20px solid transparent;
            border-right: 20px solid transparent;
            border-bottom: 40px solid var(--accent);
            position: absolute; bottom: 0; left: 50%; /* variable */
            transform: translateX(-50%);
            transition: left 0.3s ease;
        }

        /* Gauges */
        .gauges-panel {
            display: flex; justify-content: space-between; width: 100%; max-width: 900px;
            margin-top: 100px;
        }

        .gauge {
            width: 300px; padding: 20px;
            background: var(--panel); border: 2px solid var(--border);
            border-radius: 10px;
            display: flex; flex-direction: column; align-items: center;
        }
        .gauge-title { font-family: 'Teko'; font-size: 1.5rem; color: #aaa; }
        .gauge-val { font-size: 2.5rem; font-weight: bold; margin: 10px 0; }
        .gauge-calc { font-size: 0.9rem; color: #7f8c8d; }
        
        #g-left { border-color: #f38ba8; }
        #g-right { border-color: #a6e3a1; }

        /* Modal */
        .modal {
            position: fixed; inset: 0; background: rgba(30, 30, 46, 0.95);
            display: flex; align-items: center; justify-content: center;
            z-index: 100;
        }
        .modal.hidden { display: none; }
        
        .dialog {
            background: var(--panel); padding: 40px; border-radius: 12px;
            max-width: 500px; text-align: center;
            box-shadow: 0 0 30px rgba(0,0,0,0.5); border: 1px solid var(--highlight);
        }

        button {
            background: var(--highlight); color: #1e1e2e; border: none;
            padding: 10px 30px; font-family: 'Teko'; font-size: 1.5rem;
            cursor: pointer; margin-top: 20px; transition: 0.2s;
        }
        button:hover { background: #fff; transform: scale(1.05); }

    
        .alert-modal-wrap {
            position: fixed; inset: 0; background: rgba(0,0,0,0.5);
            display: none; justify-content: center; align-items: center;
            z-index: 100;
        }
        .alert-modal {
            background: white; padding: 2rem; border-radius: 8px;
            text-align: center; min-width: 300px; box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }
        .alert-modal p { margin: 0 0 1rem 0; font-size: 1rem; color: #333; }
        .alert-modal button {
            background: #4b5563; color: white; padding: 0.8rem 2rem;
            border: none; border-radius: 6px; cursor: pointer;
        }
        .alert-modal button:hover { opacity: 0.9; }
</style>
</head>
<body>

<header>
    <h1>EQUILIBRIUM SCALE</h1>
    <div class="param-badge">
        <span>L-FACTOR: <span id="val-l" style="color:var(--danger)">--</span></span>
        <span style="color:#666">|</span>
        <span>R-FACTOR: <span id="val-r" style="color:var(--success)">--</span></span>
    </div>
</header>

<main>
    <div class="scale-container">
        <div class="beam-wrapper" id="beam-wrap">
            <div class="weights-container" id="w-cont">
                <!-- Weights -->
            </div>
            <div class="beam"></div>
        </div>
        
        <div class="fulcrum-track">
            <div class="fulcrum" id="fulcrum"></div>
        </div>
    </div>

    <div class="gauges-panel">
        <div class="gauge" id="g-left">
            <div class="gauge-title">LEFT TORQUE</div>
            <div class="gauge-val" id="disp-l">0</div>
            <div class="gauge-calc">SUM(Left) × L</div>
        </div>
        
        <div class="gauge" id="g-right">
            <div class="gauge-title">RIGHT TORQUE</div>
            <div class="gauge-val" id="disp-r">0</div>
            <div class="gauge-calc">SUM(Right) × R</div>
        </div>
    </div>
</main>

<div id="modal" class="modal">
    <div class="dialog">
        <h2 style="font-family:'Teko'; font-size:2rem; margin-bottom:10px; color:var(--highlight)">BALANCE PROTOCOL</h2>
        <b>Objective:</b>
        <div style="text-align:left; font-size:1.1rem; margin:1.5rem 0; line-height:1.6; color:var(--text);">
            Find the **Pivot Index** `i` that balances the scale.<br>
            <br>
            <b>Condition:</b><br>
            <span style="font-family:monospace; background:rgba(0,0,0,0.3); padding:2px 5px;">(SumLeft × L) == (SumRight × R)</span><br>
            <br>
            <b>Controls:</b><br>
            Click a weight to set it as the Pivot (Fulcrum).
        </div>
        <button onclick="game.start()">CALIBRATE</button>
    </div>
</div>

<script>
    class Game {
        constructor() {
            this.n = 7;
            this.arr = [];
            this.L = 1;
            this.R = 1;
            
            this.ui = {
                wCont: document.getElementById('w-cont'),
                fulcrum: document.getElementById('fulcrum'),
                beamWrap: document.getElementById('beam-wrap'),
                dispL: document.getElementById('disp-l'),
                dispR: document.getElementById('disp-r'),
                valL: document.getElementById('val-l'),
                valR: document.getElementById('val-r'),
                modal: document.getElementById('modal')
            };
        }

        start() {
            this.ui.modal.classList.add('hidden');
            this.loadLevel();
        }

        loadLevel() {
            this.n = 7 + Math.floor(Math.random()*4); // 7-10
            this.arr = Array.from({length: this.n}, () => Math.floor(Math.random()*10)+1);
            
            // Generate L and R such that a solution exists?
            // Random L, R usually results in NO solution.
            // Let's force a solution.
            // Pick a pivot index 'p'.
            // Calc sumL (exc p), sumR (exc p).
            // Need sumL * L == sumR * R.
            // Let L = sumR, R = sumL. Simplify by GCD.
            
            const p = Math.floor(Math.random() * (this.n - 2)) + 1; // avoid ends
            let sumL = 0; for(let i=0; i<p; i++) sumL += this.arr[i];
            let sumR = 0; for(let i=p+1; i<this.n; i++) sumR += this.arr[i];
            
            // If sum is 0 (unlikely with positive nums), just use 1.
            // Simplify ratio
            const gcd = (a, b) => b==0 ? a : gcd(b, a%b);
            const common = gcd(sumL, sumR);
            
            this.L = sumR / common;
            this.R = sumL / common;
            
            // Randomly scale L and R? No, keep simple.
            
            this.ui.valL.innerText = this.L;
            this.ui.valR.innerText = this.R;
            
            this.renderWeights();
            this.setPivot(Math.floor(this.n/2)); // Initial center, likely unbalanced
        }

        renderWeights() {
            this.ui.wCont.innerHTML = '';
            this.arr.forEach((val, i) => {
                const box = document.createElement('div');
                box.className = 'weight-box';
                box.innerHTML = `<span style="font-size:0.8rem; color:#aaa; margin-bottom:2px">${i}</span><b>${val}</b>`;
                box.onclick = () => this.setPivot(i);
                box.id = `w-${i}`;
                this.ui.wCont.appendChild(box);
            });
        }

        setPivot(idx) {
            // Update UI Pivot Highlight
            document.querySelectorAll('.weight-box').forEach(b => b.classList.remove('pivot'));
            document.getElementById(`w-${idx}`).classList.add('pivot');
            
            // Move Fulcrum
            // Calculate position % based on index spread
            // Weights spread 0 to 100% in w-cont (with padding).
            // Actually flex space-around places them uniformly.
            // Center of item i is at roughly (i + 0.5) / n * 100% of w-cont width?
            // Let's rely on DOM offset.
            
            const target = document.getElementById(`w-${idx}`);
            // We need relative position of center of target within container
            const contRect = this.ui.wCont.getBoundingClientRect();
            const targetRect = target.getBoundingClientRect();
            
            const relCenter = (targetRect.left + targetRect.width/2) - contRect.left;
            const pct = (relCenter / contRect.width) * 100;
            
            this.ui.fulcrum.style.left = pct + '%';
            
            this.checkBalance(idx);
        }

        checkBalance(idx) {
            let sL = 0; for(let i=0; i<idx; i++) sL += this.arr[i];
            let sR = 0; for(let i=idx+1; i<this.n; i++) sR += this.arr[i];
            
            const torqueL = sL * this.L;
            const torqueR = sR * this.R;
            
            this.ui.dispL.innerText = torqueL;
            this.ui.dispR.innerText = torqueR;
            
            // Animate Beam Tilt
            let tilt = 0;
            if (torqueL > torqueR) tilt = -10; // Left heavy -> tilt CCW
            else if (torqueR > torqueL) tilt = 10; // Right heavy -> tilt CW
            else tilt = 0;
            
            this.ui.beamWrap.style.transform = `rotate(${tilt}deg)`;
            
            if (tilt === 0) {
                // Success
                this.ui.dispL.style.color = "var(--success)";
                this.ui.dispR.style.color = "var(--success)";
                setTimeout(() => {
                    this.showGameAlert("BALANCE ACHIEVED!");
                    this.loadLevel();
                }, 1000);
            } else {
                this.ui.dispL.style.color = "var(--text)";
                this.ui.dispR.style.color = "var(--text)";
            }
        }
    }

    const game = new Game();
</script>
</body>
</html>
